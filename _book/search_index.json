[
["index.html", "数据科学中的 R 语言 前言 关于课程 RYouWithMe 致谢", " 数据科学中的 R 语言 王敏杰 2020-03-16 前言 你好，这里是四川师范大学研究生公选课《数据科学中的R语言》的课程内容。考虑到大家来自不同的学院，有着不同的学科背景，因此讲授的内容不会太深奥（要有信心喔）。 比如在课程中以下内容就不会出现 \\[ f(x)=\\frac{1}{\\sqrt{2 \\pi}} e^{-\\frac{1}{2} x^{2}} \\] 而出现更多的是 library(tidyverse) summary_monthly_temp &lt;- weather %&gt;% group_by(month) %&gt;% summarize(mean = mean(temp), std_dev = sd(temp)) 在跟进本课程的同时， 我强烈推荐大家阅读Hadley Wickham的 r4ds这本书 (Grolemund and Wickham 2017)。作者可是2019年8月刚刚获得考普斯总统奖（被誉为统计学的诺贝尔奖）的大神喔，点击这里可以看他照片。 关于课程 1、课程安排是这样的，每个章节研究的内容都是彼此独立的，大家可以单独阅读每章及运行代码。 基础篇 第 1 章介绍数据科学基础 第 2 章介绍R语言基本概念 第 3 章介绍R语言中的子集选取 tidyverse篇 第 4 章介绍可重复性研究 第 5 章介绍数据读入 第 6 章介绍数据规整与数据处理 第 7 章介绍数据可视化 第 8 章介绍字符串处理 第 9 章介绍函数式编程 第 10 章介绍探索性数据分析1 第 11 章介绍探索性数据分析2 第 12 章介绍探索性数据分析3 第 13 章再讲ggplot2 第 14 章介绍tidyverse中常用技巧 第 15 章介绍简单数据框 建模篇 第 16 章介绍模拟与抽样 第 17 章介绍方差分析 第 18 章介绍线性模型 第 19 章介绍机器学习 第 20 章介绍非标准性评估 应用篇 第 21 章介绍tidyverse进阶 第 22 章介绍tidyverse中行方向的操作 第 23 章介绍tidyverse中的dot 第 24 章介绍网页爬虫 第 25 章介绍社会网络分析 第 26 章介绍文本挖掘 第 27 章介绍时间序列分析 第 28 章介绍地理数据处理 第 29 章介绍我收集的一些有用和有趣的宏包 2、课件源代码和数据 我将持续改进课件，所以欢迎大家提出建议 https://github.com/perlatex/R_for_Data_Science 3、关于课程目标 课程目标: 熟悉数据科学流程，掌握统计编程技能，能运用探索性分析方法，解决基本的实际应用问题，做到学以致用，不是 learning R，而是 learning with R 授课方式: 边写代码边讲 通过案例式、问题式的方法，增强参与感和目标感 课堂要求 自带电脑，配好运行环境 4、关于如何提问 有的同学，这样一上来就问：老师，我的代码怎么运行不出来呢？或者图省事，干脆手机拍个照片一发。 我想说，要想获得快速的帮助，在问问题之前，请先告诉对方三个信息： 想解决的问题是什么？ 代码是什么？ 报错信息是什么？ RYouWithMe 致谢 非常感谢川师研究生院的信任， 有了您的支持，才会有更多的川师学子了解R的美！ 王敏杰 于 川师图书馆某角落 参考文献 "],
["author.html", "作者简介", " 作者简介 王敏杰，四川师范大学研究生公选课《数据科学中的R语言》授课老师，西南交通大学量子物理学博士，爱好数据科学，喜欢用R和Raku编程， 联系方式 38552109@qq.com "],
["intro-ds.html", "第 1 章 数据科学与R语言 1.1 什么是数据科学 1.2 数据科学流程 1.3 为什么选择 R 1.4 R vs Excel", " 第 1 章 数据科学与R语言 马克思曾说过：“一门科学只有当它达到能够成功运用数学时，才算真正得到发展。”数学为数据科学提供了坚实的理论基础，数据科学也为数学与实际应用之间建立起一个直接的桥梁。 1.1 什么是数据科学 数据科学是综合了统计学、计算机科学和领域知识的交叉学科，其基本内容就是用数据的方法研究科学，用科学的方法研究数据（鄂维南院士）。2010年，Drew Conway画了一张数据科学的韦恩图 从数据科学所涉及的学科领域来看，其知识结构不仅仅包括数学、统计学、计算机科学、信息科学等在内的基础性理论，还应该包括社会学、物理学、情报学、生物医学等在内的专业性领域理论。 （事实上，最重要的最下面那个部分，专业领域的知识） 1.2 数据科学流程 Hadley Wickham将数据科学流程分解成6个环节 即数据导入、数据规整、数据处理、可视化、建模以及形成可重复性报告，整个分析和探索过程都在一个程序代码中完成，这种方式对训练我们的数据思维非常有帮助。 1.3 为什么选择 R 2016年权威机构KDnuggets做过调研，显示数据科学领域最受欢迎的工具，是python和R两种语言 事实上，python和R都是非常强大的工具，两者各有优劣，作为初学者，究竟选择谁? 可以参考《为什么R语言是当今最值得学习的数据科学语言》，这篇文章做了详细的对比。我个人的观点是，如果想做程序员或者打算今后在工业企业里工作，可以选择python; 如果你今后打算在科研机构做学术研究，我推荐R语言作为入门语言。 2019 年国际统计学年会将考普斯总统奖（The Committee of Presidents of Statistical Societies Awards，简称 COPSS 奖，被誉为统计学的诺贝尔奖）奖颁给 tidyverse的作者Hadley Wickham后，充分说明R语言得到了学术界的肯定和认可，我相信未来它在自然科学、社会科学和工业领域中的应用前景会非常光明。 数据科学为什么选择 R &amp; tidyverse 统计 可视化 探索性分析 可重复性报告 tidyverse 语法一致性（学习一个宏包，可以帮助理解其他宏包） 代码可读性，接近人类语言 ( %&gt;% 太酷了 ) 1.4 R vs Excel 为什么不能用excel做数据分析？画个图说明下 "],
["intro-R.html", "第 2 章 R语言基础 2.1 安装 R 2.2 安装 RStudio 2.3 开始 2.4 对象 2.5 数据类型 2.6 数据结构 2.7 函数 2.8 脚本 2.9 宏包 2.10 如何获取帮助 2.11 R 语言社区 2.12 延伸阅读", " 第 2 章 R语言基础 R 软件是一个自由、开源软件平台，具有统计分析、可视化和编程的强大功能。 你可以从这里免费下载。 为了更好的使用 R 软件，我推荐大家使用 RStudio这个 IDE。这里有个在线教程帮助我们熟悉 R 和 RStudio。 2.1 安装 R 我们从官方网站http://cran.r-project.org下载, 网站界面感觉有点朴素: 2.2 安装 RStudio 安装完R， 还需要安装RStudio。有同学可能要问 R 与 RStudio 是什么关系呢？打个比方吧，R 就像汽车的发动机, RStudio 就是汽车的仪表盘。 同样，我们从官方网站下载并安装，苹果系统的用户，选择苹果系统对应的rstudio版本即可。 https://www.rstudio.com/download 选择RStudio Desktop 这里有个小小的提示： 电脑不要用中文用户名，否则Rstudio会杠上中文用户名 尽量安装在非系统盘，比如，可以选择安装在D盘 安装路径不要有中文和空格。比如，这样就比较好 D:/R D:/Rstudio 2.3 开始 安装完毕后，从windos开始菜单，点开rstudio图标，就打开了rstudio的窗口，界面效果如下 RStudio 的用户界面十分友好，想要运行一段R代码，只需要在 RStudio 控制台面板最下面一行内键入R 代码，然后回车即可。比如我们键入1 + 1 并按回车后，RStudio 将显示如下结果 1 + 1 ## [1] 2 log(8) ## [1] 2.079 1:15 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 2.4 对象 在R中存储的数据称为对象， R语言数据处理实际上就是不断的创建和操控这些对象。创建一个R对象，首先确定一个名称，然后使用 赋值操作符 &lt;-，将数据赋值给它。比如，如果想给变量 x 赋值为5，在命令行中可以这样写 x &lt;- 5 ，然后回车. x &lt;- 5 当键入x 然后回车，就打印出 x 的值。当然也可以使用命令print(x)，结果一样。 x ## [1] 5 x + 2 ## [1] 7 die &lt;- 1:6 die ## [1] 1 2 3 4 5 6 die / 2 ## [1] 0.5 1.0 1.5 2.0 2.5 3.0 die * die ## [1] 1 4 9 16 25 36 die %*% die ## [,1] ## [1,] 91 die %o% die ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 2 3 4 5 6 ## [2,] 2 4 6 8 10 12 ## [3,] 3 6 9 12 15 18 ## [4,] 4 8 12 16 20 24 ## [5,] 5 10 15 20 25 30 ## [6,] 6 12 18 24 30 36 2.5 数据类型 数值型 3 ## [1] 3 5000 ## [1] 5000 3e+06 ## [1] 3e+06 class(0.0001) ## [1] &quot;numeric&quot; 字符串型 &quot;hello&quot; ## [1] &quot;hello&quot; &quot;girl&quot; ## [1] &quot;girl&quot; &quot;1&quot; # 1 vs &quot;1&quot; ## [1] &quot;1&quot; class(&quot;1&quot;) ## [1] &quot;character&quot; 逻辑型 TRUE ## [1] TRUE FALSE ## [1] FALSE 3 &lt; 4 ## [1] TRUE class(T) ## [1] &quot;logical&quot; 3 &lt; 4 ## [1] TRUE 因子型 fac &lt;- factor(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) fac ## [1] a b c ## Levels: a b c class(fac) ## [1] &quot;factor&quot; 2.6 数据结构 大家前面看到x &lt;- 1 和 x &lt;- c(1, 2, 3)，这就是最简单的数据对象，叫原子型向量。 用c函数将一组数据构造成向量 die &lt;- c(2, 4, 3, 1, 5, 7) die ## [1] 2 4 3 1 5 7 长度为 1 的原子型向量 x &lt;- 1 # or x &lt;- c(1) 强制转换 vec &lt;- c(&quot;R&quot;, 1, TRUE) class(vec) ## [1] &quot;character&quot; 大家看到前面die %o% die 是矩阵类型，矩阵就是二维数组 可以用matrix 函数创建 m &lt;- matrix(c(2, 4, 3, 1, 5, 7), nrow = 2, ncol = 3, byrow = TRUE ) m ## [,1] [,2] [,3] ## [1,] 2 4 3 ## [2,] 1 5 7 数据对象：数组 array 函数生成n维数组 ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3)) ar ## , , 1 ## ## [,1] [,2] ## [1,] 11 13 ## [2,] 12 14 ## ## , , 2 ## ## [,1] [,2] ## [1,] 21 23 ## [2,] 22 24 ## ## , , 3 ## ## [,1] [,2] ## [1,] 31 33 ## [2,] 32 34 数据对象：列表 与c函数创建向量的方式相似，不同的元素用逗号分开。不同的是，列表允许不同的数据类型（数值型，字符型，逻辑型等）， 而向量要求每个元素的数据类型必须相同。 list1 &lt;- list(100:110, &quot;R&quot;, c(2, 4, 3, 1, 5, 7)) list1 ## [[1]] ## [1] 100 101 102 103 104 105 106 107 108 109 110 ## ## [[2]] ## [1] &quot;R&quot; ## ## [[3]] ## [1] 2 4 3 1 5 7 数据对象：数据框 data.frame函数构建 df &lt;- data.frame( name = c(&quot;ace&quot;, &quot;bob&quot;, &quot;carl&quot;, &quot;kaite&quot;), age = c(21, 14, 13, 15), sex = c(&quot;girl&quot;, &quot;boy&quot;, &quot;boy&quot;, &quot;girl&quot;) ) df R 对象的数据结构(向量、矩阵、数组、列表和数据框)，总结如下 为了更好地理解相关概念，建议大家阅读Garrett Grolemund的 hopr这本书 (Grolemund 2014)。 2.7 函数 R 语言的强大在于使用函数操控各种对象，你可以把对象看作是名词，而函数看作是动词。 我们用一个简单的例子，sum()来演示函数如何工作的。这个函数的功能正如它的名字一样，对输入的各个对象求和，然后返回求和后的值，你可以在命令行中键入?sum()查看其官方文档。 sum()后的结果可以直接显示出来，也可以赋名。比如下面代码，首先计算x + 10并赋以名字y， 然后第二行中打印出来这个新创建的对象y y &lt;- sum(x, 10) y ## [1] 11 因为代码的灵活性，可以不断地重新定义对象。只要数据发生改变，原来的代码就会返回新的值。比如，对x重新赋值为 15， 同样运行sum()函数，这次我们不赋值给对象y，而是让它直接显示 x &lt;- 15 sum(x, 10) ## [1] 25 再比如 round(3.14159) ## [1] 3 mean(1:6) ## [1] 3.5 n &lt;- 100 x &lt;- seq(1, n) sum(x) ## [1] 5050 dt &lt;- mtcars[, 1:4] head(dt) cor(dt) ## mpg cyl disp hp ## mpg 1.0000 -0.8522 -0.8476 -0.7762 ## cyl -0.8522 1.0000 0.9020 0.8324 ## disp -0.8476 0.9020 1.0000 0.7909 ## hp -0.7762 0.8324 0.7909 1.0000 2.8 脚本 如果我们已经写好了一段R程序，我们可以保存为脚本文件，脚本文件通常以.R作为文件的后缀名。比如我们可以将刚才创建x和 y对象的命令，保存为脚本文件my_script.R。 这样我们可以在其它时间修改和重新运行它。 在RStudio中，你可以通过菜单栏依此点击File &gt; New File &gt; R Script 来创建一个新的脚本。 强烈建议大家在运行代码之前，使用脚本的形式编写和编辑自己的程序，养成这样的习惯后，你今后所有的工作都有案可查，并且具有可重复性。 点击 Run 或者 Source 运行脚本 2.9 宏包 R 语言的强大还在于各种宏包，一般在The Comprehensive R Archive Network (CRAN)下载安装。宏包扩展了R语言本身的各种功能，也为解决问题提供了各种方案。截至撰写本书时止，CRAN上大约有1.4万个宏包可以使用。但由于各种包接口不统一，语法不一致，也带来一些困扰。为了解决这个问题，RStudio 公司的Hadley Wickham 与其带领的团队推出了tidyverse宏包， tidyverse将常用的宏包整合在一起，并保持了语法的一致性。可以说，tidyverse宏包是R语言入门 学习的首选。 本书正是基于tidyverse宏包而成的，本书也将通过一些例子不断地展示tidyverse在数据分析和可视化的应用。 可以用如下命令安装 ggplot2 宏包: # 安装单个包 install.packages(&quot;tidyverse&quot;) # 安装多个包 install.packages(c(&quot;ggplot2&quot;, &quot;devtools&quot;, &quot;dplyr&quot;)) 如果下载速度太慢，可以选择国内镜像 如果安装宏包过程中出错，可以试试这样 install.packages(&quot;tidyverse&quot;, repos = &quot;http://cran.rstudio.com&quot;) # 或者 install.packages(&quot;tidyverse&quot;, repos = &quot;https://CRAN.R-project.org&quot;) 如果遇到如下报错信息 Warning in install.packages : unable to access index for repository http://cran.rstudio.com/src/contrib: cannot open URL &#39;http://cran.rstudio.com/src/contrib/PACKAGES&#39; 输入下面命令后，再试试 options(download.file.method=&quot;libcurl&quot;) 或者打开D:\\R\\etc\\Rprofile.site，添加以下内容： local({r &lt;- getOption(&quot;repos&quot;) r[&quot;CRAN&quot;] &lt;- &quot;http://mirrors.tuna.tsinghua.edu.cn/CRAN&quot; options(repos=r)}) options(download.file.method=&quot;libcurl&quot;) 如果打开代码是乱码，可以试试修改如下设置 2.10 如何获取帮助 记住和学习所有的函数几乎是不可能的 打开函数的帮助页面(Rstudio右下面板的Help选项卡) ?sqrt ?gather ?spread ?ggplot2 ?scale ?map_dfr 比如： 2.11 R 语言社区 R 语言社区非常友好，可以在这里找到你问题的答案 twitter: https://twitter.com/ R-Bloggers: https://www.r-bloggers.com/ kaggle: https://www.kaggle.com/ stackoverflow: https://stackoverflow.com/questions/tagged/r rstudio: https://community.rstudio.com/ 2.12 延伸阅读 如何获取向量a &lt;- c(\"a\", \"c\", \"e\")的第二个元素？矩阵和列表的时候，又该如何? 试试 c(1, FALSE) 与 c(\"a\", TRUE) 会是什么？ 1 == \"1\" 和 -1 &lt; FALSE 为什么为真？ \"one\" &lt; 2 为什么为假？ R语言里可以构造哪些数据对象？ 数据框可以装载哪些数据类型的数据？ 数据框和列表区别在哪里？ ()与[]区别？ 参考文献 "],
["subsetting.html", "第 3 章 子集选取 3.1 向量 3.2 列表 3.3 矩阵 3.4 数据框 3.5 增强型数据框 3.6 延伸阅读", " 第 3 章 子集选取 子集选取单独作一章，说明它确实很重要。 上一章讲对象、数据类型和数据结构等概念。为了方便理解，我这里打个比方， 对象就是我们在计算机里新建了存储空间，好比一个盒子， 我们可以往盒子里面装东西，比如鞋子、袜子、糖果东西。数据类型就是指我们装的东西的类型，比如是吃的还是用的呢， 只不过计算机用的是机器语言，称之为，数值型、字符串型、因子型等等。 数据结构就是盒子里东西的摆放次序，是相同的（同质）放一起，还是不同的（异质）放一起， 相同的放一起就是向量、矩阵；不同的放一起可能是列表和数据框。 子集选取，就是从盒子里取东西出来1。 3.1 向量 对于原子型向量，我们有至少四种方法取子集 x &lt;- c(1.1, 2.2, 3.3, 4.4, 5.5) 正整数： 指定向量元素中的位置 x[1] ## [1] 1.1 x[c(3,1)] ## [1] 3.3 1.1 负整数：删除指定位置的元素 x[-2] ## [1] 1.1 3.3 4.4 5.5 逻辑向量：将TRUE对应位置的元素提取出来 x[c(TRUE, FALSE, TRUE, FALSE, TRUE)] ## [1] 1.1 3.3 5.5 如果是命名向量 y &lt;- c(&quot;a&quot; = 11, &quot;b&quot; = 12, &quot;c&quot; = 13, &quot;d&quot; = 14) y ## a b c d ## 11 12 13 14 我们可以用名字向量，返回对应位置的向量 y[c(&quot;d&quot;, &quot;c&quot;, &quot;a&quot;)] ## d c a ## 14 13 11 3.2 列表 对列表取子集，和向量的方法一样。使用[总是返回列表，[[和$ 返回列表中的元素 l &lt;- list(&quot;one&quot; = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;two&quot; = c(1:5), &quot;three&quot; = c(TRUE, FALSE) ) l ## $one ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## ## $two ## [1] 1 2 3 4 5 ## ## $three ## [1] TRUE FALSE l[1] ## $one ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; l[[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 也可以 l[[&quot;one&quot;]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 取出one位置上的元素，需要写[[\"one\"]]， 程序员觉得太麻烦了，所以用$来简写 l$one ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 所以请记住 [ 和[[的区别 x$y 是 x[[\"y\"]]的简写 3.3 矩阵 a &lt;- matrix(1:9, nrow = 3) a ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 我们取第1到2行的2-3列，[1:2, 2:3]，中间以逗号分隔，于是得到一个新的矩阵 a[1:2, 2:3] ## [,1] [,2] ## [1,] 4 7 ## [2,] 5 8 默认情况下, [ 会将获取的数据，以尽可能低的维度形式呈现。比如 a[1, 1:2] ## [1] 1 4 表示第1行的第1、2列，此时不是\\(1 \\times 2\\)矩阵，而是包含了两个元素的向量。 以尽可能低的维度形式呈现，换句话说，这个1, 4长的像个矩阵，又有点像向量，向量的维度比矩阵低，那就是向量吧。 有些时候，我们想保留所有的行或者列，比如这里我们选取1到2行的所有列，可以这样简写 a[1:2, ] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 想想，会输出什么 a[,] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 可以再简化点？ a[] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 是不是可以再简化点？ a ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 3.4 数据框 数据框具有list和matrix的属性，因此 当选取数据框的某几列的时候，可以和list一样，指定元素位置，比如df[1:2]选取前两列 也可以像矩阵一样，使用行和列的标识选取，比如df[1:3, ]选取前三行的所有列 df &lt;- data.frame(x = 1:4, y = 4:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) df # Like a list df[c(&quot;x&quot;, &quot;z&quot;)] # Like a matrix df[, c(&quot;x&quot;, &quot;z&quot;)] 也可以通过行和列的位置 df[1:2] df[1:3, ] 也和矩阵一样，遇到单行单列的时候，数据会降维 df[, &quot;x&quot;] ## [1] 1 2 3 4 如果不想避免降维，需要多写一句话 df[, &quot;x&quot;, drop = FALSE] 这样输出的还是矩阵形式, 但程序员总是偷懒的，有时候我们也容易忘记写drop = FALSE， 所以我比较喜欢下面的tibble. 3.5 增强型数据框 tibble是增强型的data.frame，选取tibble的行或者列，即使遇到单行或者单列的时候，数据也不会降维，总是返回tibble，即仍然是数据框的形式。 tb &lt;- tibble::tibble( x = 1:4, y = 4:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) ) tb tb[&quot;x&quot;] tb[, &quot;x&quot;] 除此以外，tibble还有很多优良的特性，我们会在第 15 章专门讲 3.6 延伸阅读 如何获取matrix(1:9, nrow = 3)上对角元? 对角元？ 对数据框，思考df[\"x\"]， df[[\"x\"]]， df$x三者的区别? 如果x是一个矩阵，请问 x[] &lt;- 0 和x &lt;- 0 有什么区别？ m &lt;- matrix(1:9, nrow = 3) m diag(m) upper.tri(m, diag = FALSE) m[upper.tri(m, diag = FALSE)] 操控盒子里的东西，比如把糖果变大，这个过程叫函数.↩︎ "],
["rmarkdown.html", "第 4 章 可重复性研究 4.1 什么是Rmarkdown 4.2 markdown 基本语法 4.3 Communicating with Data via R Markdown 4.4 Hello R Markdown 4.5 html_document 4.6 pdf_document 4.7 延伸阅读", " 第 4 章 可重复性研究 有时候，我们需要展示和分享我们的数据分析结果给同行、老板或者老师。 那么，为了让老板能快速地的理解我们的分析思路和方法， 最好的方法，就是将分析背景、分析过程、分析结果以及图表等形成报告，让读者能重复和验证我们的结果，确保结论的真实可信。 因此，本章就将介绍如何生成分析报告（可重复性报告）。 4.1 什么是Rmarkdown 4.2 markdown 基本语法 # This is a title # 第一章 （注意 &quot;#&quot; 与 &quot;第一章&quot;之间有空格） ## 第一节 （同上，&quot;##&quot; 与 &quot;第一节&quot;之间有空格） This is a sentence. Now a list begins: - no importance - again - repeat A numbered list: 1. first 2. second __bold__, _italic_, ~~strike through~~ 4.3 Communicating with Data via R Markdown Instructions 安装最新版本 R (&gt;3.5) 和 RStudio Desktop (&gt;1.2). 安装 LaTeX. 然而这个软件会比较大 (e.g. MacTeX is approximate 3.9G). 如果你之前没有安装过 LaTeX，我推荐你安装轻量级的 tinytex. 安装方法如下，打开R，然后再命令行输入: install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() 安装如下宏包（可选）: install.packages(c(&quot;tidyverse&quot;, &quot;rmarkdown&quot;, &quot;knitr&quot;, &quot;xaringan&quot;, &quot;usethis&quot;, &quot;rmdformats&quot;, &quot;prettydoc&quot;, &quot;rticles&quot;, &quot;linl&quot;, &quot;shiny&quot;, &quot;bookdown&quot;, &quot;pagedown&quot;, &quot;remotes&quot;)) # the following is not on CRAN remotes::install_github(&quot;gadenbuie/xaringanthemer&quot;) remotes::install_github(&quot;hadley/emo&quot;) 4.4 Hello R Markdown Rstudio create Rmd file ： File -&gt; New File -&gt; R Markdown. 基本构成 metadata text code 4.4.1 插入公式 $$\\frac{\\sum (\\bar{x} - x_i)^2}{n-1}$$ \\[\\frac{\\sum (\\bar{x} - x_i)^2}{n-1}\\] 4.4.2 插入图片 knitr::include_graphics(&quot;images/R_logo.png&quot;) 4.4.3 表格 knitr::kable(iris[1:5, ], caption = &quot;A caption&quot;) 表 4.1: A caption Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 需要更优美的表格，可参考这里 4.5 html_document --- title: Habits author: John Doe date: &quot;2020-03-16&quot; output: html_document: df_print: paged toc: yes number_sections: yes --- 4.6 pdf_document --- title: &#39;Going deeper with dplyr&#39; author: &quot;王小二&quot; date: 2018-09-27 output: pdf_document: latex_engine: xelatex extra_dependencies: ctex: UTF8 number_sections: yes toc: yes classoptions: &quot;hyperref, 12pt, a4paper&quot; --- 4.7 延伸阅读 Markdown tutorial https://www.markdowntutorial.com (10分钟学完) LaTeX tutorial https://www.latex-tutorial.com/quick-start/ "],
["readr.html", "第 5 章 读取数据 5.1 常见格式 5.2 范例 5.3 乱码情形", " 第 5 章 读取数据 本章介绍如何读取数据到 R。事实上，R语言提供了很多读取数据的函数。 5.1 常见格式 下表列出了常见文件格式的读取方法 文件格式 R 函数 .txt read.table() .csv read.csv() and readr::read_csv() .xls and .xlsx readxl::read_excel() and openxlsx::read.xlsx() .sav foreign::read.spss() .Rdata or rda load() .rds readRDS() and readr::read_rds() .dta haven::read_dta() and haven::read_stata() Internet download.file() 5.2 范例 d &lt;- read.table(file= &quot;./data/txt_file.txt&quot;, header = TRUE) load(file = &quot;./data/rda_file.rda&quot;) d &lt;- readRDS(file = &quot;./data/rds_file.rds&quot;) library(readr) d &lt;- read_csv(file = &quot;./data/csv_file.csv&quot;) url &lt;- &quot;https://raw.githubusercontent.com/perlatex/R_for_Data_Science/master/demo_data/wages.csv&quot; d &lt;- read_csv(url) library(readxl) d &lt;- read_excel(&quot;./data/vowel_data.xlsx&quot;) library(haven) d &lt;- read_excel(&quot;./data/cfps2010.dta&quot;) 5.3 乱码情形 遇到乱码的情况，这里有个小小的提示： 可以先用记事本转换成“UTF-8”编码， 或者指定编码格式，比如read.table(…, fileEncoding = “UTF-8”)，再试试。 "],
["dplyr.html", "第 6 章 数据处理 6.1 mutate() 6.2 管道 %&gt;% 6.3 select() 6.4 filter() 6.5 summarise()统计 6.6 group_by()分组 6.7 arrange()排序 6.8 left_join 6.9 延伸阅读", " 第 6 章 数据处理 Hadley Wickhamt提出了数据科学tidy原则，我结合自己的理解，tidy思想体现在: 一切都是数据框，任何数据都可以规整 数据框的一列代表一个变量，数据框的一行代表一次观察 函数处理数据时，数据框进数据框出（函数的第一个参数始终为数据框） 本章我们介绍tidyverse里数据处理的神器dplyr宏包。首先，我们加载该宏包 library(dplyr) dplyr 定义了数据处理的规范语法，其中主要包含以下七个主要的函数。 mutate(), select(), filter() summarise(), group_by(), arrange() left_join(), right_join()， full_join() 我们依次介绍 6.1 mutate() 假定我们有一数据框，包含三位学生的英语和数学 df &lt;- data.frame( name = c(&quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;Carol&quot;), type = c(&quot;english&quot;, &quot;math&quot;, &quot;english&quot;, &quot;math&quot;, &quot;english&quot;, &quot;math&quot;) ) df 这里有他们的考试成绩， 我们想增加到数据框里去 score2020 &lt;- c(80.2, 90.5, 92.2, 90.8, 82.5, 84.6) score2020 ## [1] 80.2 90.5 92.2 90.8 82.5 84.6 df$score &lt;- score2020 df dplyr语法这样写 mutate(.data = df, score4 = score2020) mutate() 函数第一参数是我们要处理的数据框，比如这里的df， 第二个参数是score = score2020， 等号左边的score是我们打算创建一个新列，而取的列名； 等号右边是装着学生成绩的向量（注意，向量 的长度要与数据框的行数相等，比如这里长度都是6） 6.2 管道 %&gt;% 这里有必要介绍下管道操作符%&gt;%. c(1:10) ## [1] 1 2 3 4 5 6 7 8 9 10 sum(c(1:10)) ## [1] 55 与下面的写法是等价的, c(1:10) %&gt;% sum() ## [1] 55 这条语句的意思，向量c(1:10) 通过管道操作符 %&gt;% ，传递到函数sum()的第一个参数位置，即sum(c(1:10))， 这个%&gt;%管道操作符还是很形象的， 当对执行多个函数操作的时候，就显得格外方便，代码可读性更强。 sqrt(sum(abs(c(-10:10)))) ## [1] 10.49 # sqrt(sum(abs(c(-10:10)))) c(-10:10) %&gt;% abs() %&gt;% sum() %&gt;% sqrt() ## [1] 10.49 那么，上面增加学生成绩的语句mutate(df, score = score2020)就可以使用管道 # 等价于 df %&gt;% mutate(score = score2020) 是不是很赞？ df &lt;- df %&gt;% mutate(score = score2020) df 6.3 select() select()顾名思义选择，就是选择数据框的某一列，我们还是以学生成绩的数据框为例 我们可以选择name列, 结果是只有一列的数据框（仍然数据框喔） df[&quot;name&quot;] # df[&quot;name&quot;] df %&gt;% select(name) 如果选取多列，就再写一个就行了 df %&gt;% select(name, score) 如果不想要某列， 可以在变量前面加-， 结果与上面的一样 df %&gt;% select(-type) 6.4 filter() select是列方向的选择， 我们还可以对数据行方向的选择和筛选，比如这里把成绩高于90分的同学筛选出来 df %&gt;% filter(score &gt;= 90) 也可以限定多个条件进行筛选, 英语成绩高于90分的筛选出来 df %&gt;% filter(type == &quot;english&quot;, score &gt;= 90) df 6.5 summarise()统计 summarise()主要用于统计，往往与其他函数配合使用，比如计算所有同学的考试成绩的均值 df %&gt;% summarise( mean_score = mean(score)) 还同时完成多个统计 df %&gt;% summarise( mean_score = mean(score), median_score = median(score), n = n(), sum = sum(score) ) 6.6 group_by()分组 事实上，summarise()往往配合group_by()一起使用，即，先分组再统计。比如，我们想统计每个学生的平均成绩，那么就需要先按学生name分组，然后求平均 df %&gt;% group_by(name) %&gt;% summarise( mean_score = mean(score), sd_score = sd(score) ) 6.7 arrange()排序 这个很好理解的。比如我们按照考试成绩从低到高排序，然后输出 df %&gt;% arrange(score) 如果从高到低排序呢，有两种方法: df %&gt;% arrange(-score) 写成下面这种形式也是降序排列，但可读性更强些 df %&gt;% arrange(desc(score)) 也可对多个变量先后排序。先按学科排，然后按照成绩从高到底排序 df %&gt;% arrange(type, desc(score)) 6.8 left_join 数据框合并，假定我们已经统计了每个同学的平均成绩，存放在df1 df1 &lt;- df %&gt;% group_by(name) %&gt;% summarise( mean_score = mean(score) ) df1 我们有新一个数据框df2，包含同学们的年龄信息 df2 &lt;- tibble( name = c(&quot;Alice&quot;, &quot;Bob&quot;), age = c(12, 13) ) df2 可以用 left_join把两个数据框df1和df2，合并连接再一起, 两个数据框是通过姓名name连接的，因此需要指定by = \"name\" left_join(df1, df2, by = &quot;name&quot;) # df1 %&gt;% left_join(df2, by = &quot;name&quot;) 大家注意到最后一行Carol的年龄是NA， 大家想想为什么呢？ 我们再试试right_join() df1 %&gt;% right_join(df2, by = &quot;name&quot;) Carol同学的信息没有了？ 大家想想又为什么呢？ 事实上，答案就在函数的名字上，left_join()是左合并，即以左边数据框df1中的学生姓名name为准，在右边数据框df2里，有Alice和Bob的年龄，那么就对应合并过来，没有Carol，就为缺失值NA left_join()是右合并，即以右边数据框df2中的学生姓名name为准，只有Alice和Bob，因此而df1只需要把Alice和Bob的信息粘过来。 6.9 延伸阅读 推荐https://dplyr.tidyverse.org/. cheatsheet 作业：读懂并运行下面的代码 Download nycflights.Rmd "],
["visual.html", "第 7 章 数据可视化 7.1 为什么要可视化 7.2 宏包ggplot2 7.3 ggplot2 的图形语法 7.4 映射 7.5 映射 vs.设置 7.6 几何对象 7.7 Global vs. Local 7.8 saving plots 7.9 延伸阅读", " 第 7 章 数据可视化 上节课介绍了R语言的基本数据结构，可能大家有种看美剧的感觉，有些懵。这很正常，我在开始学习R的时候，感觉和大家一样，所以不要惊慌，我们后面会慢慢填补这些知识点。 这节课，我们介绍R语言最强大的可视化，看看都有哪些炫酷的操作。 library(tidyverse) # install.packages(&quot;tidyverse&quot;) library(patchwork) # install.packages(&quot;patchwork&quot;) 7.1 为什么要可视化 我们先从一个故事开始，1854年伦敦爆发严重霍乱，当时流行的观点是霍乱是通过空气传播的，而John Snow医生（不是《权力的游戏》里的 Jon Snow）研究发现，霍乱是通过饮用水传播的。研究过程中，John Snow医生统计每户病亡人数，每死亡一人标注一条横线，分析发现，大多数病例的住所都围绕在Broad Street水泵附近，结合其他证据得出饮用水传播的结论，于是移掉了Broad Street水泵的把手，霍乱最终得到控制。 另一个有趣的例子就是辛普森悖论（Simpson’s Paradox）。比如我们想研究下，学习时间和考试成绩的关联。结果发现两者呈负相关性，即补课时间越长，考试成绩反而越差（下图横坐标是学习时间，纵坐标是考试成绩），很明显这个结果有违生活常识。 事实上，当我们把学生按照不同年级分成五组，再来观察学习时间和考试成绩之间的关联，发现相关性完全逆转了! 我们可以看到学习时间和考试成绩强烈正相关。 辛普森悖论在日常生活中层出不穷。 那么如何避免辛普森悖论呢？我们能做的，就是仔细地研究分析各种影响因素，不要笼统概括地、浅尝辄止地看问题。其中，可视化分析为我们提供了一个好的方法。 7.2 宏包ggplot2 ggplot2是RStudio首席科学家Hadley Wickham在2005年读博士期间的作品。很多人学习R语言，就是因为ggplot2宏包。目前， ggplot2已经发展成为最受欢迎的R宏包，没有之一。 我们可以看看它2019年cran的下载量 library(cranlogs) d &lt;- cran_downloads(package = &quot;ggplot2&quot;, from = &quot;2019-01-01&quot;, to = &quot;2019-12-31&quot;) sum(d$count) ## [1] 9889742 7.3 ggplot2 的图形语法 ggplot2有一套优雅的绘图语法，包名中“gg”是grammar of graphics的简称。 ggplot()函数包括9个部件： 数据 (data) （ 数据框） 映射 (mapping) 几何对象 (geom) 统计变换 (stats) 标度 (scale) 坐标系 (coord) 分面 (facet) 主题 (theme) 存储和输出 (output) 其中前三个是必需的。 Hadley Wickham将这套语法诠释为: 一张统计图形就是从数据到几何对象(geometric object，缩写geom)的图形属性(aesthetic attribute，缩写aes)的一个映射。 此外，图形中还可能包含数据的统计变换(statistical transformation，缩写stats)，最后绘制在某个特定的坐标系(coordinate system，缩写coord)中，而分面(facet)则可以用来生成数据不同子集的图形。 7.3.1 语法模板 先看一个简单的案例（1880-2014年温度变化和二氧化碳排放量） library(tidyverse) d &lt;- read_csv(&quot;./demo_data/temp_carbon.csv&quot;) d library(ggplot2) ggplot(data = d, mapping = aes(x = year, y = carbon_emissions)) + geom_line() + xlab(&quot;Year&quot;) + ylab(&quot;Carbon emissions (metric tons)&quot;) + ggtitle(&quot;Annual global carbon emissions, 1880-2014&quot;) 7.4 映射 我们用ggplot2宏包内置数据集mpg来演示 1999年和2008年期间，市面上38种流行车型，燃油经济性数据 mpg包含234行和11个变量的数据框 str(mpg) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 234 obs. of 11 variables: ## $ manufacturer: chr &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; &quot;audi&quot; ... ## $ model : chr &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; &quot;a4&quot; ... ## $ displ : num 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ... ## $ year : int 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ... ## $ cyl : int 4 4 4 4 6 6 6 4 4 4 ... ## $ trans : chr &quot;auto(l5)&quot; &quot;manual(m5)&quot; &quot;manual(m6)&quot; &quot;auto(av)&quot; ... ## $ drv : chr &quot;f&quot; &quot;f&quot; &quot;f&quot; &quot;f&quot; ... ## $ cty : int 18 21 20 21 16 18 18 18 16 20 ... ## $ hwy : int 29 29 31 30 26 26 27 26 25 28 ... ## $ fl : chr &quot;p&quot; &quot;p&quot; &quot;p&quot; &quot;p&quot; ... ## $ class : chr &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; &quot;compact&quot; ... 序号 变量 含义 1 manufacturer 生产厂家 2 model 类型 3 displ 发动机排量，升 4 year 生产年份 5 cyl 气缸数量 6 trans 传输类型 7 drv 驱动类型(f =前轮驱动，r =后轮驱动，4 = 4wd) 8 cty 每加仑城市里程 9 hwy 每加仑高速公路英里 10 fl 汽油种类 11 class 类型 7.4.1 排量越大，越耗油吗？ 这里提出一个问题，是不是汽车的排量越大越耗油吗？ 回答这个问题，我们用到mpg数据集其中的三个变量 displ： 发动机排量, 排量 hwy： 每加仑英里数，油耗 class：汽车类型 mpg[c(&quot;displ&quot;, &quot;hwy&quot;, &quot;class&quot;)] 为考察，发动机排量(displ)与每加仑英里数(hwy)之间的关联，先绘制这两个变量的散点图， ggplot()表示调用该函数画图，data = mpg 表示使用mpg这个数据框来画图。 aes()表示数据和视觉属性之间的映射， aes(x = displ, y = hwy)，意思是变量displ作为（映射为）x轴方向的位置，变量hwy作为（映射为）y轴方向的位置。 aes()除了位置上映射，还可以实现色彩、形状或透明度等视觉属性的映射。 geom_point()表示绘制散点图。 +表示添加图层。 运行脚本后生成图片： 刚才看到的是位置上的映射，ggplot还包含了颜色、形状以及透明度等图形属性的映射， 比如我们在aes()里增加一个color = class, 具体来说，不同的汽车类型, 用不同的颜色来表现。 ggplot(data = mpg, aes(x = displ, y = hwy, color = class) ) + geom_point() 此图绘制不同类型的车，displ和hwy的散点图， 用颜色来实现分组。 大家试试下面代码呢， ggplot(data = mpg, aes(x = displ, y = hwy, size = class)) + geom_point() ggplot(data = mpg, aes(x = displ, y = hwy, shape = class)) + geom_point() ggplot(data = mpg, aes(x = displ, y = hwy, alpha = class)) + geom_point() 一些默认的设置 7.5 映射 vs.设置 想把图中的点指定为某一种颜色，可以使用设置语句，比如 ggplot(mpg, aes(displ, hwy)) + geom_point(color = &quot;blue&quot;) 大家也可以试试下面 ggplot(mpg, aes(displ, hwy)) + geom_point(size = 5) ggplot(mpg, aes(displ, hwy)) + geom_point(shape = 2) ggplot(mpg, aes(displ, hwy)) + geom_point(alpha = 0.5) 7.5.1 提问 思考下aes(color = \"blue\")为什么会红色的点？ ggplot(mpg, aes(x = displ, y = hwy, color = &quot;ffee&quot;)) + geom_point() mpg[c(&quot;displ&quot;, &quot;hwy&quot;, &quot;class&quot;)] mpg$col &lt;- &quot;blue&quot; mpg[c(&quot;displ&quot;, &quot;hwy&quot;, &quot;class&quot;, &quot;col&quot;)] ggplot(mpg, aes(x = displ, y = hwy, color = col)) + geom_point() 7.6 几何对象 geom_point() 可以画散点图，也可以使用geom_smooth()绘制平滑曲线， p1 &lt;- ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() p1 p2 &lt;- ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_smooth() p2 p3 &lt;- ggplot(data = mpg, aes(x = displ, y = hwy)) + geom_point() + geom_smooth() p3 library(patchwork) (p1 / p2) | p3 7.7 Global vs. Local ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(aes(x = displ, y = hwy, color = class)) ggplot(mpg) + geom_point( aes(x = displ, y = hwy, color = class) ) 大家可以看到，以上两段代码出来的图是一样。但背后的含义却不同。 事实上，如果映射关系aes() 写在ggplot()里, ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point() x = displ, y = hwy, color = class 为全局变量。 如果映射关系aes() 写在几何对象geom_point()里, 就为局部变量, 比如。 ggplot(mpg) + geom_point(aes(x = displ, y = hwy, color = class)) 如果geom_point()中缺少所绘图所需要的映射关系，就会继承全局变量的映射关系aes(x = displ, y = hwy, color = class) 。 ggplot(mpg, aes(x = displ, y = hwy)) + geom_point(aes(color = class)) + geom_smooth() 这里的 geom_point() 和 geom_smooth() 都会从全局变量中继承映射关系。 如果局部变量中的映射关系已经存在，那么就不会从全局变量中继承，沿用当前的映射关系。 ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_point(aes(color = factor(cyl))) 大家细细体会下，下面两段代码的区别 ggplot(mpg, aes(x = displ, y = hwy, color = class)) + geom_smooth(method = lm) + geom_point() ggplot(mpg, aes(x = displ, y = hwy)) + geom_smooth(method = lm) + geom_point(aes(color = class)) 7.8 saving plots 可以使用ggsave()函数，将图片保存为所需要的格式，如“.pdf”, “.png”等 p &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + geom_smooth(method = lm) + geom_point(aes(color = class)) + ggtitle(&quot;This is my first plot&quot;) ggsave(filename = &quot;myfirst_plot.pdf&quot;, plot = p, width = 8, height = 6, dpi = 300) 7.9 延伸阅读 在第 13 章会再讲ggplot2 "],
["stringr.html", "第 8 章 正则表达式 8.1 什么是正则表达式 8.2 字符串基础 8.3 使用正则表达式进行模式匹配 8.4 解决实际问题 8.5 进阶部分 8.6 案例分析 8.7 一些有趣的正则表达式的宏包", " 第 8 章 正则表达式 library(tidyverse) library(stringr) 8.1 什么是正则表达式 我们在word文档或者excel中，经常使用查找和替换, 然而有些情况，word是解决不了的，比如 条件搜索 统计文中，前面有 “data”, “computer” or “statistical” 的 “analysis”，这个单词的个数 找出文中重复的单词，比如“we love love you” 拼写检查 电话号码（邮件，密码等）是否正确格式 日期书写的规范与统一 提取信息 提取文本特定位置的数据 文本挖掘 非结构化的提取成结构化 这个时候就需要用到正则表达式（Regular Expression），这一强大、便捷、高效的文本处理工具。那么，什么是正则表达式呢？简单点说，正则表达式是处理字符串的。复杂点说，正则表达式描述了一种字符串匹配的模式（pattern），通常被用来检索、替换那些符合某个模式(规则)的文本。这种固定的格式的文本，生活中常见的有电话号码、网络地址、邮件地址和日期格式等等。 正则表达式并不是R语言特有的，事实上，几乎所有程序语言都支持正则表达式。 R语言中的字符串操作，基础包里有很多函数可以使用，然而大神Hadley Wickham开发的stringr包让正则表达式简单易懂，所以今天我们介绍这个包，本章的内容与《R for data science》第10章基本一致。本章目的教大家写简单的正则表示式就行了。 8.2 字符串基础 8.2.1 字符串长度 想获取字符串的长度，可以使用str_length()函数 str_length(&quot;R for data science&quot;) ## [1] 18 对字符串向量 str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA)) ## [1] 1 18 NA 数据框里配合dplyr函数，同样很方便 data.frame( x = c(&quot;a&quot;, &quot;R for data science&quot;, NA) ) %&gt;% mutate(y = str_length(x)) 8.2.2 字符串组合 把字符串拼接在一起 str_c(&quot;x&quot;, &quot;y&quot;) ## [1] &quot;xy&quot; 把字符串拼接在一起，可以设置中间的间隔 str_c(&quot;x&quot;, &quot;y&quot;, sep = &quot;, &quot;) ## [1] &quot;x, y&quot; str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), sep = &quot;, &quot;) ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; 是不是和你想象的不一样，那就?str_c，或者试试这个 str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), sep = &quot;, &quot;) ## [1] &quot;x, x&quot; &quot;y, y&quot; &quot;z, z&quot; 用在数据框里 data.frame( x = c(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;), y = c(&quot;you&quot;, &quot;like&quot;, &quot;me&quot;) ) %&gt;% mutate(z = str_c(x, y, sep = &quot;|&quot;)) 使用collapse选项，是先组合，然后再转换成单个字符串，大家对比下 str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), sep = &quot;|&quot;) ## [1] &quot;x|a&quot; &quot;y|b&quot; &quot;z|c&quot; str_c(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), collapse = &quot;|&quot;) ## [1] &quot;xa|yb|zc&quot; 8.2.3 字符串取子集 截取字符串的一部分，需要指定截取的开始位置和结束位置 x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, 1, 3) ## [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot; 开始位置和结束位置如果是负整数，就表示位置是从后往前数，比如下面这段代码，截取倒数第3个至倒数第1个位置上的字符串 x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;) str_sub(x, -3, -1) ## [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot; 也可以进行赋值，如果该位置上有字符，就用新的字符替换旧的字符 str_sub(x, 1, 1) &lt;- &quot;Q&quot; x ## [1] &quot;Qpple&quot; &quot;Qanana&quot; &quot;Qear&quot; 8.3 使用正则表达式进行模式匹配 正则表示式慢慢会呈现了 8.3.1 基础匹配 str_view() 是查看string是否匹配pattern，如果匹配，就高亮显示 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(string = x, pattern = &quot;an&quot;) 有时候，我们希望在字符串中，a前后都有字符（a处在两字符中间， rap, bad, sad, wave，spear等等） x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;.a.&quot;) 这里的. 代表任意字符。如果向表达.本身呢？ c(&quot;s.d&quot;) %&gt;% str_view(&quot;.&quot;) c(&quot;s.d&quot;) %&gt;% str_view(&quot;\\\\.&quot;) 8.3.2 锚点 希望a是字符串的开始 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;^a&quot;) 希望a是一字符串的末尾 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_view(x, &quot;a$&quot;) x &lt;- c(&quot;apple pie&quot;, &quot;apple&quot;, &quot;apple cake&quot;) str_view(x, &quot;^apple$&quot;) 8.3.3 字符类与字符选项 前面提到，.匹配任意字符，事实上还有很多这种特殊含义的字符： \\d: matches any digit. \\s: matches any whitespace (e.g. space, tab, newline). [abc]: matches a, b, or c. [^abc]: matches anything except a, b, or c. str_view(c(&quot;grey&quot;, &quot;gray&quot;), &quot;gr[ea]y&quot;) 8.3.4 重复 控制匹配次数: ?: 0 or 1 +: 1 or more *: 0 or more x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CC?&quot;) str_view(x, &quot;X+&quot;) 控制匹配次数: {n}: exactly n {n,}: n or more {,m}: at most m {n,m}: between n and m x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;C{2}&quot;) str_view(x, &quot;C{2,}&quot;) str_view(x, &quot;C{2,3}&quot;) 默认的情况，*, + 匹配都是贪婪的，也就是它会尽可能的匹配更多 如果想让它不贪婪，而是变得懒惰起来，可以在*, + 加个? x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_view(x, &quot;CLX+&quot;) str_view(x, &quot;CLX+?&quot;) 小结一下呢 8.3.5 分组与回溯引用 ft &lt;- fruit %&gt;% head(10) ft ## [1] &quot;apple&quot; &quot;apricot&quot; &quot;avocado&quot; ## [4] &quot;banana&quot; &quot;bell pepper&quot; &quot;bilberry&quot; ## [7] &quot;blackberry&quot; &quot;blackcurrant&quot; &quot;blood orange&quot; ## [10] &quot;blueberry&quot; 我们想看看这些单词里，有哪些字母是重复两次的，比如aa, pp. 如果用上面学的方法 str_view(ft, &quot;.{2}&quot;, match = TRUE) 发现不是和我们的预想不一样呢。 所以需要用到新技术 分组与回溯引用， str_view(ft, &quot;(.)\\\\1&quot;, match = TRUE) . 是匹配任何字符 (.) 将匹配项括起来，它就用了一个名字，叫\\\\1； 如果有两个括号，就叫\\\\1和\\\\2 \\\\1 表示回溯引用，表示引用\\\\1对于的(.) 所以(.)\\\\1的意思就是，匹配到了字符，后面还希望有个同样的字符 如果是匹配abab, wcwc str_view(ft, &quot;(..)\\\\1&quot;, match = TRUE) 如果是匹配abba, wccw呢？ str_view(ft, &quot;(.)(.)\\\\2\\\\1&quot;, match = TRUE) 是不是很神奇？ 8.4 解决实际问题 8.4.1 确定一个字符向量是否匹配一种模式 实际问题中，我们希望得到，是否匹配？或者将匹配的筛选处理， 这个时候，需要用到str_detect等函数 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_detect(x, &quot;e&quot;) ## [1] TRUE FALSE TRUE stringr::words包含了牛津字典里常用单词 stringr::words %&gt;% head() ## [1] &quot;a&quot; &quot;able&quot; &quot;about&quot; &quot;absolute&quot; ## [5] &quot;accept&quot; &quot;account&quot; 我们统计下以t开头的单词，有多少个？ # How many common words start with t? sum(str_detect(words, &quot;^t&quot;)) ## [1] 65 我们又一次看到了强制转换. 以元音结尾的单词，占比多少？ # proportion of common words end with a vowel? mean(str_detect(words, &quot;[aeiou]$&quot;)) ## [1] 0.2765 放在数据框里看看, 看看以x结尾的单词是哪些？ tibble( word = words ) %&gt;% filter(str_detect(word, &quot;x$&quot;)) str_detect() 有一个功能类似的函数str_count()，区别在于，后者不是简单地返回是或否，而是返回字符串中匹配的数量 x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;) str_count(x, &quot;a&quot;) ## [1] 1 3 1 tibble( word = words ) %&gt;% mutate( vowels = str_count(word, &quot;[aeiou]&quot;), consonants = str_count(word, &quot;[^aeiou]&quot;) ) 8.4.2 确定匹配的位置 大家放心，正则表达式不会重叠匹配。比如用\"aba\"去匹配\"abababa\"，肉眼感觉是三次，但正则表达式告诉我们是两次，因为不会重叠匹配 str_count(&quot;abababa&quot;, &quot;aba&quot;) ## [1] 2 str_view_all(&quot;abababa&quot;, &quot;aba&quot;) 8.4.3 提取匹配的内容 colours &lt;- c( &quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;purple&quot; ) colour_match &lt;- str_c(colours, collapse = &quot;|&quot;) colour_match ## [1] &quot;red|orange|yellow|green|blue|purple&quot; colour_match 这里是一个字符串，放在pattern参数位置上也是正则表达式了, 这里注意以下两者的区别 str_view(&quot;abcd&quot;, &quot;ab|cd&quot;) str_view(&quot;abc&quot;, &quot;a[bc]d&quot;) more &lt;- &quot;It is hard to erase blue or red ink.&quot; str_extract(more, pattern = colour_match) ## [1] &quot;blue&quot; str_extract_all(more, pattern = colour_match) ## [[1]] ## [1] &quot;blue&quot; &quot;red&quot; more &lt;- sentences[str_count(sentences, colour_match) &gt; 1] more ## [1] &quot;It is hard to erase blue or red ink.&quot; ## [2] &quot;The green light in the brown box flickered.&quot; ## [3] &quot;The sky in the west is tinged with orange red.&quot; 取出sentences中，含有有两种和两种颜色以上的句子。不过，不喜欢这种写法，看着费劲，还是用tidyverse的方法 tibble(sentence = sentences) %&gt;% filter(str_count(sentences, colour_match) &gt; 1) str_extract()提取匹配, 谁先匹配就提取谁 tibble(x = more) %&gt;% mutate(color = str_extract(x, colour_match)) str_extract_all()提取全部匹配项 tibble(x = more) %&gt;% mutate(color = str_extract_all(x, colour_match)) tibble(x = more) %&gt;% mutate(color = str_extract_all(x, colour_match)) %&gt;% unnest(color) 8.4.4 替换匹配内容 只替换匹配的第一项 x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;) str_replace(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-pple&quot; &quot;p-ar&quot; &quot;b-nana&quot; 替换全部匹配项 str_replace_all(x, &quot;[aeiou]&quot;, &quot;-&quot;) ## [1] &quot;-ppl-&quot; &quot;p--r&quot; &quot;b-n-n-&quot; 8.4.5 拆分字符串 这个和str_c()是相反的操作 lines &lt;- &quot;I love my country&quot; lines ## [1] &quot;I love my country&quot; str_split(lines, &quot; &quot;) ## [[1]] ## [1] &quot;I&quot; &quot;love&quot; &quot;my&quot; &quot;country&quot; fields &lt;- c(&quot;Name: Hadley&quot;, &quot;Country: NZ&quot;, &quot;Age: 35&quot;) fields %&gt;% str_split(&quot;: &quot;, n = 2, simplify = TRUE) ## [,1] [,2] ## [1,] &quot;Name&quot; &quot;Hadley&quot; ## [2,] &quot;Country&quot; &quot;NZ&quot; ## [3,] &quot;Age&quot; &quot;35&quot; 8.5 进阶部分 带有条件的匹配 8.5.1 look ahead 想匹配Windows，同时希望Windows右侧是\"95\", \"98\", \"NT\", \"2000\"中的一个 win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?=95|98|NT|2000)&quot;) win &lt;- c(&quot;Windows2000&quot;, &quot;Windows&quot;, &quot;Windows3.1&quot;) str_view(win, &quot;Windows(?!95|98|NT|2000)&quot;) Windows后面的 () 是匹配条件，事实上，有四种情形： (?=pattern) 要求此位置的后面必须匹配表达式pattern (?!pattern) 要求此位置的后面不能匹配表达式pattern (?&lt;=pattern) 要求此位置的前面必须匹配表达式pattern (?&lt;!pattern) 要求此位置的前面不能匹配表达式pattern 注意：对于正则表达式引擎来说，它是从文本头部向尾部（从左到右）开始解析的，因此对于文本尾部方向，称为“前”，因为这个时候，正则引擎还没走到那块；而对文本头部方向，则称为“后”，因为正则引擎已经走过了那一块地方。 8.5.2 look behind win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;=95|98|NT|2000)Windows&quot;) win &lt;- c(&quot;2000Windows&quot;, &quot;Windows&quot;, &quot;3.1Windows&quot;) str_view(win, &quot;(?&lt;!95|98|NT|2000)Windows&quot;) 8.6 案例分析 8.6.1 案例1 我们希望能提取第二列中的数值，构成新的一列 dt &lt;- tibble( x = 1:4, y = c(&quot;wk 3&quot;, &quot;week-1&quot;, &quot;7&quot;, &quot;w#9&quot;) ) dt dt %&gt;% mutate( z = str_extract(y, &quot;[0-9]&quot;) ) 8.6.2 案例2 提取第二列中的大写字母 df &lt;- data.frame( x = seq_along(1:7), y = c(&quot;2016123456&quot;, &quot;20150513&quot;, &quot;AB2016123456&quot;, &quot;J2017000987&quot;, &quot;B2017000987C&quot;, &quot;aksdf&quot;, &quot;2014&quot;) ) df df %&gt;% mutate( item = str_extract_all(y, &quot;[A-Z]&quot;) ) %&gt;% tidyr::unnest(item) 8.6.3 案例3 要求：中英文分开 tb &lt;- tibble(x = c(&quot;I我&quot;, &quot;love爱&quot;, &quot;you你&quot;)) tb tb %&gt;% tidyr::extract( x, c(&quot;en&quot;, &quot;cn&quot;), &quot;([:alpha:]+)([^:alpha:]+)&quot;, remove = FALSE ) 8.6.4 案例4 要求：提取起始数字 df &lt;- tibble(x = c(&quot;1-12周&quot;, &quot;1-10周&quot;, &quot;5-12周&quot;)) df df %&gt;% extract( x, c(&quot;start&quot;, &quot;end&quot;, &quot;cn&quot;), &quot;([:digit:]+)-([:digit:]+)([^:alpha:]+)&quot;, remove = FALSE ) 8.6.5 案例5 要求：提取大写字母后的数字 df &lt;- tibble( x = c(&quot;12W34&quot;, &quot;AB2C46&quot;, &quot;B217C&quot;, &quot;akTs6df&quot;, &quot;21WD4&quot;) ) df %&gt;% mutate( item = str_extract_all(x, &quot;(?&lt;=[A-Z])[0-9]&quot;) ) %&gt;% tidyr::unnest(item) 思考题， 如何提取大写字母后的连续数字，比如B217C后面的217 如何提取提取数字前的大写字母？ 为什么第一个正则表达式返回结果为\"\" x &lt;- &quot;Roman numerals: MDCCCLXXXVIII&quot; str_match_all(x, &quot;C?&quot;) # &quot;?&quot;的意思是匹配0次或者1次 ## [[1]] ## [,1] ## [1,] &quot;&quot; ## [2,] &quot;&quot; ## [3,] &quot;&quot; ## [4,] &quot;&quot; ## [5,] &quot;&quot; ## [6,] &quot;&quot; ## [7,] &quot;&quot; ## [8,] &quot;&quot; ## [9,] &quot;&quot; ## [10,] &quot;&quot; ## [11,] &quot;&quot; ## [12,] &quot;&quot; ## [13,] &quot;&quot; ## [14,] &quot;&quot; ## [15,] &quot;&quot; ## [16,] &quot;&quot; ## [17,] &quot;&quot; ## [18,] &quot;&quot; ## [19,] &quot;C&quot; ## [20,] &quot;C&quot; ## [21,] &quot;C&quot; ## [22,] &quot;&quot; ## [23,] &quot;&quot; ## [24,] &quot;&quot; ## [25,] &quot;&quot; ## [26,] &quot;&quot; ## [27,] &quot;&quot; ## [28,] &quot;&quot; ## [29,] &quot;&quot; ## [30,] &quot;&quot; str_match_all(x, &quot;CC?&quot;) ## [[1]] ## [,1] ## [1,] &quot;CC&quot; ## [2,] &quot;C&quot; 8.6.6 案例6 提取数字并求和 df &lt;- tibble( x = c(&quot;1234&quot;, &quot;B246&quot;, &quot;217C&quot;, &quot;2357f&quot;, &quot;21WD4&quot;) ) df df %&gt;% mutate(num = str_match_all(x, &quot;\\\\d&quot;)) %&gt;% unnest(num) %&gt;% mutate_at(vars(num), as.numeric) %&gt;% group_by(x) %&gt;% summarise(sum = sum(num)) 8.6.7 案例7 text &lt;- &quot;Quantum entanglement is a physical phenomenon that occurs when pairs or groups of particles are generated, interact, or share spatial proximity in ways such that the quantum state of each particle cannot be described independently of the state of the others, even when the particles are separated by a large distance.&quot; pairs &lt;- tibble::tribble( ~item, ~code, &quot;Quantum entanglement&quot;, &quot;A01&quot;, &quot;physical phenomenon&quot;, &quot;A02&quot;, &quot;quantum state&quot;, &quot;A03&quot;, &quot;quantum mechanics&quot;, &quot;A04&quot; ) %&gt;% tibble::deframe() text %&gt;% str_replace_all(pairs) ## [1] &quot;A01 is a A02 that occurs when pairs or groups of particles are generated, interact, or share spatial proximity in ways such that the A03 of each particle cannot be described independently of the state of the others, even when the particles are separated by a large distance.&quot; 8.7 一些有趣的正则表达式的宏包 https://github.com/gadenbuie/regexplain https://github.com/daranzolin/inferregex https://github.com/VerbalExpressions/RVerbalExpressions library(inferregex) # remotes::install_github(&quot;daranzolin/inferregex&quot;) s &lt;- &quot;abcd-9999-ab9&quot; infer_regex(s)$regex ## [1] &quot;^[a-z]{4}-\\\\d{4}-[a-z]{2}\\\\d$&quot; "],
["purrr.html", "第 9 章 函数式编程 9.1 简单回顾 9.2 多说说列表 9.3 列表 vs 向量 9.4 purrr 9.5 自定义函数 9.6 延伸阅读", " 第 9 章 函数式编程 很多教材都是讲函数和循环，都是从for, while, ifelse讲起 ，如果我也这样讲，又回到了Base R的老路上去了。考虑到大家都没有编程背景，也不会立志当程序员，所以我直接讲purrr包，留坑以后填吧。 9.1 简单回顾 大家知道R常用的数据结构是向量、矩阵、列表和数据框，如下图 他们构造起来，很多相似性。 list(a = 1, b = &quot;a&quot;) # 列表 c(a = 1, b = 2) # 命名向量 data.frame(a = 1, b = 2) # 数据框 tibble(a = 1, b = 2) # 增强型数据框 9.2 多说说列表 我们构造一个列表 a_list &lt;- list( num = c(8, 9), log = TRUE, cha = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ) a_list ## $num ## [1] 8 9 ## ## $log ## [1] TRUE ## ## $cha ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; 要想访问某个元素，可以这样 a_list[&quot;num&quot;] ## $num ## [1] 8 9 注意返回结果，第一行是$num，说明返回的结果仍然是列表, 相比a_list来说，a_list[\"num\"]是只包含一个元素的列表。 想将num元素里面的向量提取出来，就得用两个[[ a_list[[&quot;num&quot;]] ## [1] 8 9 大家知道程序员都是偷懒的，为了节省体力，用一个美元符号$代替[[\" \"]]六个字符 a_list$num ## [1] 8 9 在tidyverse里，还可以用 a_list %&gt;% pluck(1) ## [1] 8 9 或者 a_list %&gt;% pluck(&quot;num&quot;) ## [1] 8 9 9.3 列表 vs 向量 假定一向量 v &lt;- c(-2, -1, 0, 1, 2) v ## [1] -2 -1 0 1 2 我们对元素分别取绝对值 abs(v) ## [1] 2 1 0 1 2 如果是列表形式，abs函数应用到列表中就会报错 lst &lt;- list(-2, -1, 0, 1, 2) abs(lst) ## Error in abs(lst): 数学函数中用了非数值参数 报错了。用在向量的函数用在list上，往往行不通。 再来一个例子：我们模拟了5个学生的10次考试的成绩 exams &lt;- list( student1 = round(runif(10, 50, 100)), student2 = round(runif(10, 50, 100)), student3 = round(runif(10, 50, 100)), student4 = round(runif(10, 50, 100)), student5 = round(runif(10, 50, 100)) ) exams ## $student1 ## [1] 82 86 77 55 97 97 56 53 77 61 ## ## $student2 ## [1] 78 53 97 98 63 52 98 75 93 51 ## ## $student3 ## [1] 90 56 76 70 91 97 82 55 53 64 ## ## $student4 ## [1] 74 79 81 85 59 57 53 95 83 89 ## ## $student5 ## [1] 53 90 83 78 94 99 99 98 75 66 很显然，exams是一个列表。那么，每个学生的平均成绩是多呢？ 我们可能会想到用mean函数，但是 mean(exams) ## [1] NA 发现报错了，可以看看帮助文档看看问题出在什么地方 ?mean() 帮助文档告诉我们，mean()要求第一个参数是数值型或者逻辑型的向量。 而我们这里的exams是列表，因此无法运行。 那好，我们就用笨办法吧 list( student1 = mean(exams$student1), student2 = mean(exams$student2), student3 = mean(exams$student3), student4 = mean(exams$student4), student5 = mean(exams$student5) ) ## $student1 ## [1] 74.1 ## ## $student2 ## [1] 75.8 ## ## $student3 ## [1] 73.4 ## ## $student4 ## [1] 75.5 ## ## $student5 ## [1] 83.5 成功了。但发现我们写了好多代码，如果有100个学生，那就得写更多的代码，如果是这样，程序员就不高兴了，这太累了啊。于是purrr包的map函数来解救我们，下面主角出场了。 9.4 purrr 介绍之前，先试试 exams %&gt;% map(mean) ## $student1 ## [1] 74.1 ## ## $student2 ## [1] 75.8 ## ## $student3 ## [1] 73.4 ## ## $student4 ## [1] 75.5 ## ## $student5 ## [1] 83.5 哇，短短几句话，得出了相同的结果。如果希望返回的是数值型的向量，可以这样写 exams %&gt;% map_dbl(mean) ## student1 student2 student3 student4 student5 ## 74.1 75.8 73.4 75.5 83.5 如果希望返回的结果是数据框 exams %&gt;% map_df(mean) 是不是很酷？ 事实上，map函数 第一个参数是向量或列表（数据框是列表的一种特殊形式，因此数据框也是可以的） 第二个参数是函数，这个函数会应用到列表的每一个元素，比如这里map函数执行过程如下 ： 具体为，exams有5个元素，一个元素装着一个学生的10次考试成绩， 运行map(exams, mean)函数后， 首先取出exams第一个元素exams$student1(它是向量)，然后执行 mean(exams$student1), 然后将计算结果存放在列表result中的第一个位置result1上； 做完第一个学生的，紧接着取出exams第二个元素exams$student2，执行 mean(exams$student2), 然后将计算结果存放在列表result中的第一个位置result2上； 如此这般，直到所有学生都处理完毕。我们得到了最终结果—一个新的列表result。 当然，我们也可以根据需要，让map返回我们需要的数据格式, purrr也提供了方便的函数，具体如下 我们将mean函数换成求方差var函数试试， exams %&gt;% map_df(var) 9.5 自定义函数 刚才我们是让学生成绩执行求平均mean，求方差var等函数。我们也可以自定义函数。 比如我们这里定义了将向量中心化的函数（先求出10次考试的平均值，然后每次考试成绩去减这个平均值） my_fun &lt;- function(x){ x - mean(x) } exams %&gt;% map_df(my_fun) 当然可以偷懒将函数直接写在map()里，用~代替my_fun， 但代价是参数必须是规定的写法，比如.x exams %&gt;% map_df(~ .x - mean(.x)) 有时候，程序员觉得x还是有点多余，于是更够懒一点，只用.， 也是可以的 exams %&gt;% map_df(~ . - mean(.)) 总之，有三种方法将函数传递给map() 直接传递 map(.x, mean, na.rm = TRUE ) 匿名函数 map(.x, funciton(.x) { mean(.x, na.rm = TRUE) } ) 使用 ~ map(.x, ~ mean(.x, na.rm = TRUE) ) 9.6 延伸阅读 1、阅读Hadley Wickham的r4ds这本书第16章。 2、看手册?purrr::modify()， 思考下它与map()的区别 exams %&gt;% modify(~ . - mean(.)) 3、他们的区别哪里？函数能否互换？ mtcars %&gt;% map_chr(typeof) mtcars %&gt;% map_lgl(is.double) mtcars %&gt;% map_int(n_unique) mtcars %&gt;% map_dbl(mean) "],
["eda01.html", "第 10 章 探索性数据分析 10.1 探索性 10.2 数据集 10.3 导入数据 10.4 数据结构 10.5 我们想探索哪些问题？ 10.6 每个学科颁过多少次奖 10.7 看看我们伟大的祖国 10.8 哪些大神多次获得诺贝尔奖 10.9 大神在得奖的时候是多大年龄？ 10.10 性别比例 10.11 这些大神都是哪个年代出生的人？ 10.12 最年轻的诺奖获得者？ 10.13 平均年龄和获奖数量 10.14 出生地与工作地分布 10.15 迁移模式 10.16 地图 10.17 出生地和工作地不一样的占比 10.18 诺奖分享者 10.19 其它 10.20 延伸阅读", " 第 10 章 探索性数据分析 探索性数据分析（exporatory data analysis）是各种知识的综合运用。本章通过一个案例，讲解探索性数据分析的基本思路，也算是对前面几章内容的一次总结复习。 10.1 探索性 数据准备（对数据要做到心中有数） 描述变量 数据结构 缺失值及其处理 数据探索（围绕探索的目标） 数据规整 可视化 建模 10.2 数据集 这是一个诺贝尔奖获得者的数据集， 10.3 导入数据 library(tidyverse) library(lubridate) df &lt;- read_csv(&quot;./demo_data/nobel_winners.csv&quot;) df # 如果是xlsx格式 readxl::read_excel(&quot;myfile.xlsx&quot;) # 如果是csv格式 readr::read_csv(&quot;myfile.csv&quot;) 这里有个小小的提示： 路径（包括文件名）， 不要用中文和空格 数据框中变量，也不要有中文和空格（可用下划线代替空格） 10.4 数据结构 一行就是一个诺奖获得者的记录? 确定？ 缺失值及其处理 df %&gt;% map_df(~sum(is.na(.))) 性别缺失怎么造成的？ df %&gt;% count(laureate_type) 10.5 我们想探索哪些问题？ 你想关心哪些问题，可能是 每个学科颁过多少次奖？ 这些大神都是哪个年代的人？ 性别比例 平均年龄和获奖数量 最年轻的诺奖获得者是谁？ 中国诺奖获得者有哪些？ 得奖的时候多大年龄？ 获奖者所在国家的经济情况？ 有大神多次获得诺贝尔奖，而且在不同科学领域获奖？ 出生地分布？工作地分布？迁移模式？ GDP经济与诺奖模型？ 诺奖分享情况？ 10.6 每个学科颁过多少次奖 df %&gt;% count(category) df %&gt;% count(category) %&gt;% ggplot(aes(x = category, y = n, fill = category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;不同学科诺贝奖获奖次数对比&quot;, x = &quot;学科&quot;, y = &quot;数量&quot;) + theme(legend.position = &quot;none&quot;) df %&gt;% count(category) %&gt;% ggplot(aes(x = fct_reorder(category, n), y = n, fill = category)) + geom_col() + geom_text(aes(label = n), vjust = -0.25) + labs(title = &quot;不同学科诺贝奖获奖次数对比&quot;, x = &quot;学科&quot;, y = &quot;数量&quot;) + theme(legend.position = &quot;none&quot;) 也可以使用别人定义好的配色方案 library(ggthemr) # install.packages(&quot;devtools&quot;) # devtools::install_github(&#39;cttobin/ggthemr&#39;) ggthemr(&#39;dust&#39;) df %&gt;% count(category) %&gt;% ggplot(aes(x = fct_reorder(category, n), y = n, fill = category)) + geom_col() + labs(title = &quot;不同学科诺贝奖获奖次数对比&quot;, x = &quot;学科&quot;, y = &quot;数量&quot;) + theme(legend.position = &quot;none&quot;) 这个配色方案感觉挺好看的呢，比较适合我这种又挑剔又懒惰的人。 当然，也可以自己DIY，或者使用配色网站的主题方案(https://learnui.design/tools/data-color-picker.html#palette) df %&gt;% count(category) %&gt;% ggplot(aes(x = fct_reorder(category, n), y = n)) + geom_col(fill = c(&quot;#003f5c&quot;, &quot;#444e86&quot;, &quot;#955196&quot;, &quot;#dd5182&quot;, &quot;#ff6e54&quot;, &quot;#ffa600&quot;) ) + labs(title = &quot;不同学科诺贝奖获奖次数对比&quot;, x = &quot;学科&quot;, y = &quot;数量&quot;) + theme(legend.position = &quot;none&quot;) 让图骚动起来吧 library(gganimate) #install.packages(&quot;gganimate&quot;, dependencies = T) df %&gt;% count(category) %&gt;% mutate(category = fct_reorder(category, n)) %&gt;% ggplot(aes(x = category, y = n)) + geom_text(aes(label = n), vjust = -0.25) + geom_col(fill = c(&quot;#003f5c&quot;, &quot;#444e86&quot;, &quot;#955196&quot;, &quot;#dd5182&quot;, &quot;#ff6e54&quot;, &quot;#ffa600&quot;) ) + labs(title = &quot;不同学科诺贝奖获奖次数对比&quot;, x = &quot;学科&quot;, y = &quot;数量&quot;) + theme(legend.position = &quot;none&quot;) + transition_states(category) + shadow_mark(past = TRUE) 和ggplot2的分面一样，动态图可以增加数据展示的维度。 10.7 看看我们伟大的祖国 df %&gt;% filter(birth_country == &quot;China&quot;) %&gt;% select(full_name, prize_year, category) 我们发现获奖者有多个地址，就会有重复的情况，比如 Charles Kuen Kao在2009年Physics有两次，为什么重复计数了呢？ 下面我们去重吧， 去重可以用distinct()函数 dt &lt;- tibble::tribble( ~x, ~y, ~z, 1, 1, &quot;a&quot;, 1, 1, &quot;b&quot;, 1, 2, &quot;c&quot;, 1, 2, &quot;d&quot; ) dt dt %&gt;% distinct_at(vars(x), .keep_all = T) dt %&gt;% distinct_at(vars(x, y), .keep_all = T) nobel_winners &lt;- df %&gt;% mutate_if(is.character, tolower) %&gt;% distinct_at(vars(full_name, prize_year, category), .keep_all = TRUE) %&gt;% mutate(decade = 10 * (prize_year %/% 10), prize_age = prize_year - year(birth_date)) nobel_winners 这是时候，我们才对数据有了一个初步的了解 再来看看我的祖国 nobel_winners %&gt;% filter(birth_country == &quot;china&quot;) %&gt;% select(full_name, prize_year, category) 10.8 哪些大神多次获得诺贝尔奖 nobel_winners %&gt;% count(full_name, sort =T) nobel_winners %&gt;% group_by(full_name) %&gt;% mutate( number_prize = n(), number_cateory = n_distinct(category) ) %&gt;% arrange(desc(number_prize), full_name) %&gt;% filter(number_cateory == 2) 10.9 大神在得奖的时候是多大年龄？ nobel_winners %&gt;% count(prize_age) %&gt;% ggplot(aes(x = prize_age, y = n)) + geom_col() nobel_winners %&gt;% group_by(category) %&gt;% summarise(mean_prize_age = mean(prize_age, na.rm = T) ) nobel_winners %&gt;% mutate(category = fct_reorder(category, prize_age, median, na.rm = TRUE)) %&gt;% ggplot(aes(category, prize_age)) + geom_point() + geom_boxplot() + coord_flip() nobel_winners %&gt;% filter(!is.na(prize_age)) %&gt;% group_by(decade, category) %&gt;% summarize(average_age = mean(prize_age), median_age = median(prize_age)) %&gt;% ggplot(aes(decade, average_age, color = category)) + geom_line() library(ggridges) nobel_winners %&gt;% ggplot(aes(x = prize_age, y = category, fill = category)) + geom_density_ridges() 他们60多少岁才得诺奖，大家才23或24岁，还年轻，不用焦虑喔。 nobel_winners %&gt;% ggplot(aes(x = prize_age, fill = category, color = category)) + geom_density() + facet_wrap(vars(category)) + theme(legend.position = &quot;none&quot;) 有同学说要一个个的画，至于group_split()函数，下次课在讲 nobel_winners %&gt;% group_split(category) %&gt;% map( ~ ggplot(data = .x, aes(x = prize_age)) + geom_density() + ggtitle(.x$category) ) ## [[1]] ## ## [[2]] ## ## [[3]] ## ## [[4]] ## ## [[5]] ## ## [[6]] 也可以用强大的group_by() + group_map()组合，我们会在第 21 章讲到 nobel_winners %&gt;% group_by(category) %&gt;% group_map( ~ ggplot(data = .x, aes(x = prize_age)) + geom_density() + ggtitle(.y) ) 10.10 性别比例 nobel_winners %&gt;% filter(laureate_type == &quot;individual&quot;) %&gt;% count(category, gender) %&gt;% group_by(category) %&gt;% mutate(prop = n / sum(n) ) 各年代性别比例 nobel_winners %&gt;% filter(laureate_type == &quot;individual&quot;) %&gt;% # mutate(decade = glue::glue(&quot;{round(prize_year - 1, -1)}s&quot;)) %&gt;% count(decade, category, gender) %&gt;% group_by(decade, category) %&gt;% mutate(prop = n / sum(n)) %&gt;% ggplot(aes(decade, category, fill = prop)) + geom_tile(size = 0.7) + #geom_text(aes(label = scales::percent(prop, accuracy = .01))) + geom_text(aes(label = scales::number(prop, accuracy = .01))) + facet_grid(vars(gender)) + scale_fill_gradient(low = &quot;#FDF4E9&quot;, high = &quot;#834C0D&quot;) library(ggbeeswarm)#install.packages(&quot;ggbeeswarm&quot;) nobel_winners %&gt;% ggplot(aes(x = category, y = prize_age, colour = gender, alpha = gender)) + ggbeeswarm::geom_beeswarm() + coord_flip() + scale_color_manual(values = c(&quot;#BB1288&quot;, &quot;#5867A6&quot;)) + scale_alpha_manual(values = c(1, .4)) + theme_minimal() + theme(legend.position = &quot;top&quot;) + labs(title = &quot;诺奖获得者性别不平衡&quot;, subtitle = &quot;1901年-2016年数据&quot;, colour = &quot;Gender&quot;, alpha = &quot;Gender&quot;, x = &quot;学科&quot;, y = &quot;获奖年龄&quot;) nobel_winners %&gt;% count(decade, category, gender = coalesce(gender, laureate_type)) %&gt;% group_by(decade, category) %&gt;% mutate(percent = n / sum(n)) %&gt;% ggplot(aes(decade, n, fill = gender)) + geom_col() + facet_wrap(~ category) + labs(x = &quot;Decade&quot;, y = &quot;# of nobel prize winners&quot;, fill = &quot;Gender&quot;, title = &quot;Nobel Prize gender distribution over time&quot;) 10.11 这些大神都是哪个年代出生的人？ nobel_winners %&gt;% select(category, birth_date) %&gt;% mutate(year = floor(year(birth_date)/10) * 10 ) %&gt;% count(category, year) %&gt;% filter(!is.na(year)) %&gt;% ggplot(aes(x = year, y = n)) + geom_col() + scale_x_continuous(breaks = seq(1810, 1990, 20)) + geom_text(aes(label = n), vjust = -0.25) + facet_wrap(vars(category)) 课堂练习，哪位同学能把图弄得好看些？ 10.12 最年轻的诺奖获得者？ nobel_winners %&gt;% filter(prize_age == min(prize_age, na.rm = T)) nobel_winners %&gt;% filter( rank(prize_year - year(birth_date) ) == 1 ) nobel_winners %&gt;% arrange( prize_year - year(birth_date) ) nobel_winners %&gt;% top_n(1, year(birth_date) - prize_year ) 10.13 平均年龄和获奖数量 df1 &lt;- nobel_winners %&gt;% group_by(category) %&gt;% summarise( mean_prise_age = mean(prize_age, na.rm = T), total_num = n() ) df1 df1 %&gt;% ggplot(aes(mean_prise_age, total_num)) + geom_point(aes(color = category)) + geom_smooth(method = lm, se = FALSE) 10.14 出生地与工作地分布 nobel_winners_clean &lt;- nobel_winners %&gt;% mutate_at( vars(birth_country, death_country), ~ ifelse(str_detect(., &quot;\\\\(&quot; ), str_extract(., &quot;(?&lt;=\\\\().*?(?=\\\\))&quot; ), .) ) %&gt;% mutate_at( vars(birth_country, death_country), ~ case_when( . == &quot;scotland&quot; ~ &quot;united kingdom&quot;, . == &quot;northern ireland&quot; ~ &quot;united kingdom&quot;, str_detect(., &quot;czech&quot;) ~ &quot;czechia&quot;, str_detect(., &quot;germany&quot;) ~ &quot;germany&quot;, TRUE ~ . ) ) %&gt;% select(full_name, prize_year, category, birth_date, birth_country, gender, organization_name, organization_country, death_country) nobel_winners_clean %&gt;% count(death_country, sort = TRUE) 10.15 迁移模式 nobel_winners_clean %&gt;% mutate( colour = case_when( death_country == &quot;united states of america&quot; ~ &quot;#FF2B4F&quot;, death_country == &quot;germany&quot; ~ &quot;#fcab27&quot;, death_country == &quot;united kingdom&quot; ~ &quot;#3686d3&quot;, death_country == &quot;france&quot; ~ &quot;#88398a&quot;, death_country == &quot;switzerland&quot; ~ &quot;#20d4bc&quot;, TRUE ~ &quot;gray60&quot; ) ) %&gt;% ggplot(aes( x = 0, y = fct_rev(factor(birth_country)), xend = death_country, yend = 1, colour = colour, alpha = (colour != &quot;gray60&quot;) )) + geom_curve(curvature = -0.5, arrow = arrow(length = unit(0.01, &quot;npc&quot;))) + scale_x_discrete() + scale_y_discrete() + scale_color_identity() + scale_alpha_manual(values = c(0.1, 0.2), guide = F) + scale_size_manual(values = c(0.1, 0.4), guide = F) + theme_minimal() + theme( panel.grid = element_blank(), plot.background = element_rect(fill = &quot;#F0EFF1&quot;, colour = &quot;#F0EFF1&quot;), legend.position = &quot;none&quot;, axis.text.x = element_text(angle = 40, hjust = 1) ) 10.16 地图 library(here) library(sf) library(countrycode) #countrycode(&#39;Albania&#39;, &#39;country.name&#39;, &#39;iso3c&#39;) nobel_winners_birth_country &lt;- nobel_winners_clean %&gt;% count(birth_country) %&gt;% filter(!is.na(birth_country)) %&gt;% mutate(ISO3 = countrycode(birth_country, origin = &quot;country.name&quot;, destination = &quot;iso3c&quot;)) global &lt;- sf::st_read(&quot;./demo_data/worldmap/TM_WORLD_BORDERS_SIMPL-0.3.shp&quot;) %&gt;% st_transform(4326) ## Reading layer `TM_WORLD_BORDERS_SIMPL-0.3&#39; from data source `E:\\R_for_Data_Science\\demo_data\\worldmap\\TM_WORLD_BORDERS_SIMPL-0.3.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 246 features and 11 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -180 ymin: -90 xmax: 180 ymax: 83.57 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs global %&gt;% full_join(nobel_winners_birth_country, by = &quot;ISO3&quot;) %&gt;% ggplot() + geom_sf(aes(fill = n), color = &quot;white&quot;, size = 0.1 ) + labs( x = NULL, y = NULL, title = &quot;Nobel Winners by country&quot;, subtitle = &quot;color of map indicates number of Nobel lauretes&quot;, fill = &quot;num of Nobel lauretes&quot;, caption = &quot;Made: wang_minjie&quot; ) + scale_fill_gradientn(colors = c(&quot;royalblue1&quot;,&quot;magenta&quot;,&quot;orange&quot;,&quot;gold&quot;), na.value = &quot;white&quot;) + #scale_fill_gradient(low = &quot;wheat1&quot;, high = &quot;red&quot;) + theme_void() + theme( legend.position = c(0.1, 0.3), plot.background = element_rect(fill = &quot;gray&quot;) ) # Determine to 10 Countries topCountries &lt;- nobel_winners_clean %&gt;% count(birth_country, sort = TRUE) %&gt;% na.omit() %&gt;% top_n(8) topCountries df4 &lt;- nobel_winners_clean %&gt;% filter(birth_country %in% topCountries$birth_country) %&gt;% group_by(birth_country, category, prize_year) %&gt;% summarise(prizes = n()) %&gt;% mutate(cumPrizes = cumsum(prizes)) df4 library(gganimate) df4 %&gt;% mutate(prize_year = as.integer(prize_year)) %&gt;% ggplot(aes(x = birth_country, y = category, color = birth_country)) + geom_point(aes(size = cumPrizes), alpha = 0.6) + #geom_text(aes(label = cumPrizes)) + scale_size_continuous(range = c(2, 30)) + transition_reveal(prize_year) + labs(title = &#39;诺奖获得者最多的10个国家&#39;, subtitle = &quot;Year: {frame_along}&quot;, y = &#39;Category&#39;) + theme_minimal() + theme( plot.title = element_text(size = 22), axis.title = element_blank()) + scale_color_brewer(palette = &quot;RdYlBu&quot;) + theme(legend.position = &quot;none&quot;) + theme(plot.margin = margin(5.5, 5.5, 5.5, 5.5)) 10.17 出生地和工作地不一样的占比 nobel_winners_clean %&gt;% select(category, birth_country, death_country) %&gt;% mutate(immigration = if_else(birth_country == death_country, 0, 1)) 10.18 诺奖分享者 nobel_winners %&gt;% separate(prize_share, into = c(&quot;num&quot;, &quot;deno&quot;), sep = &quot;/&quot;, remove = FALSE) nobel_winners %&gt;% filter(category == &quot;medicine&quot;) %&gt;% mutate(num_a = as.numeric(str_sub(prize_share, 1, 1)), num_b = as.numeric(str_sub(prize_share, -1)), share = num_a/num_b, year = prize_year %% 10, decade = 10 * (prize_year %/% 10) ) %&gt;% group_by(prize_year) %&gt;% mutate(n = row_number()) %&gt;% ggplot() + geom_col(aes(x = &quot;&quot;, y = share, fill = as.factor(n)), show.legend = FALSE ) + coord_polar(&quot;y&quot;) + facet_grid(decade ~ year, switch = &quot;both&quot;) + labs(title = &quot;每年诺贝尔奖分享情况&quot;) + theme_void() + theme( plot.title = element_text(face = &quot;bold&quot;, vjust = 8), strip.text.x = element_text(size = 7, margin = margin(t = 5)), strip.text.y = element_text(size = 7, angle = 180, hjust = 1, margin = margin(r = 10)) ) 10.19 其它 没有回答的问题，大家自己花时间探索下。 10.20 延伸阅读 有些图可以再美化下 "],
["eda02.html", "第 11 章 探索性数据分析2 11.1 导入数据 11.2 可视化 11.3 回归分析 11.4 预测 11.5 再次可视化 11.6 list_column", " 第 11 章 探索性数据分析2 这是Nature期刊上的一篇文章Nature. 2004 September 30; 431(7008)， 在文章补充材料里，我们找到了文章使用的数据，现在的任务是，重复这张图和文章的分析过程 11.1 导入数据 library(tidyverse) library(readxl) library(lubridate) library(broom) library(modelr) d &lt;- read_excel(&quot;./demo_data/olympics.xlsx&quot;) d 11.2 可视化 d1 &lt;- d %&gt;% # mutate_at( # vars(Olympic_year), as.character) %&gt;% pivot_longer( cols = -Olympic_year, names_to = &quot;sex&quot;, values_to = &quot;winning_time&quot; ) d1 d1 %&gt;% mutate_at(vars(Olympic_year), as.character) %&gt;% mutate( sex = factor(sex, levels = c(&quot;Women&quot;, &quot;Men&quot;)) ) %&gt;% ggplot(aes( x = Olympic_year, y = winning_time, group = sex, color = sex )) + geom_point() + theme(axis.text.x = element_text( size = 10, angle = 45, colour = &quot;black&quot;, vjust = 1, hjust = 1 )) 11.3 回归分析 lm(Men ~ Olympic_year, data = d) %&gt;% summary() ## ## Call: ## lm(formula = Men ~ Olympic_year, data = d) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.26371 -0.05270 0.00738 0.08005 0.21456 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 31.826453 1.679643 18.9 4.1e-15 *** ## Olympic_year -0.011006 0.000859 -12.8 1.1e-11 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.135 on 22 degrees of freedom ## (3 observations deleted due to missingness) ## Multiple R-squared: 0.882, Adjusted R-squared: 0.876 ## F-statistic: 164 on 1 and 22 DF, p-value: 1.13e-11 lm(Women ~ Olympic_year, data = d) %&gt;% summary() ## ## Call: ## lm(formula = Women ~ Olympic_year, data = d) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.3758 -0.0846 0.0093 0.0829 0.3223 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 44.34705 4.28425 10.35 1.7e-08 *** ## Olympic_year -0.01682 0.00218 -7.73 8.6e-07 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.21 on 16 degrees of freedom ## (9 observations deleted due to missingness) ## Multiple R-squared: 0.789, Adjusted R-squared: 0.776 ## F-statistic: 59.8 on 1 and 16 DF, p-value: 8.63e-07 library(equatiomatic) mod &lt;- lm(Women ~ Olympic_year, data = d) extract_eq(mod, use_coefs = TRUE) \\[ \\text{Women} = 44.35 - 0.02(\\text{Olympic\\_year}) + \\epsilon \\] library(report) report(mod) ## We fitted a linear model to predict Women with Olympic_year.The model&#39;s explanatory power is substantial (R2 = 0.79, adj. R2 = 0.78). The model&#39;s intercept is at 0.00. Within this model: ## ## - The effect of Olympic_year is negative and can be considered as significant (beta = -0.89, 95% CI [-1.13, -0.64], p &lt; .001). 11.4 预测 grid &lt;- tibble( Olympic_year = as.numeric(seq(1900, 2252, by = 4)) ) grid fit_1 &lt;- lm(Men ~ Olympic_year, data = d) # predict(fit_1, newdata = grid) fit_2 &lt;- lm(Women ~ Olympic_year, data = d) # predict(fit_2, newdata = grid) tb &lt;- grid %&gt;% mutate( Men = predict(fit_1, newdata = grid), Women = predict(fit_2, newdata = grid) ) tb 11.5 再次可视化 tb1 &lt;- tb %&gt;% pivot_longer( cols = -Olympic_year, names_to = &quot;sex&quot;, values_to = &quot;winning_time&quot; ) tb1 tb1 %&gt;% ggplot(aes( x = Olympic_year, y = winning_time, group = sex, color = sex )) + geom_point() + geom_line(size = 2) + geom_point(data = d1) + scale_x_continuous( breaks = seq(1900, 2252, by = 16), labels = as.character(seq(1900, 2252, by = 16)) ) + theme(axis.text.x = element_text( size = 10, angle = 45, colour = &quot;black&quot;, vjust = 1, hjust = 1 )) 早知道nature文章这么简单，10年前我也可以写啊 11.6 list_column 这里是另外的一种方法 d1 &lt;- d %&gt;% pivot_longer( cols = -Olympic_year, names_to = &quot;sex&quot;, values_to = &quot;winning_time&quot; ) fit_model &lt;- function(df) lm(winning_time ~ Olympic_year, data = df) d2 &lt;- d1 %&gt;% group_nest(sex) %&gt;% mutate( mod = map(data, fit_model) ) d2 # d2 %&gt;% mutate(p = list(grid, grid)) # d3 &lt;- d2 %&gt;% mutate(p = list(grid, grid)) # d3 # d3 %&gt;% # mutate( # predictions = map2(p, mod, add_predictions), # ) # or tb4 &lt;- d2 %&gt;% mutate( predictions = map(mod, ~ add_predictions(grid, .)) ) %&gt;% select(sex, predictions) %&gt;% unnest(predictions) tb4 %&gt;% ggplot(aes( x = Olympic_year, y = pred, group = sex, color = sex )) + geom_point() + geom_line(size = 2) + geom_point( data = d1, aes( x = Olympic_year, y = winning_time, group = sex, color = sex ) ) + scale_x_continuous( breaks = seq(1900, 2252, by = 16), labels = as.character(seq(1900, 2252, by = 16)) ) + theme(axis.text.x = element_text( size = 10, angle = 45, colour = &quot;black&quot;, vjust = 1, hjust = 1 )) "],
["eda03.html", "第 12 章 探索性数据分析3 12.1 读取数据 12.2 可视化探索 12.3 地图 12.4 更多", " 第 12 章 探索性数据分析3 新型冠状病毒肺炎（俗称武汉肺炎）疫情在多国蔓延，本章通过分析数据，了解疫情发展 12.1 读取数据 library(tidyverse) library(maps) library(viridis) library(shadowtext) library(showtext) showtext_auto() d &lt;- read_csv(&quot;./demo_data/time_series_19-covid-Confirmed.csv&quot;) d1 &lt;- d %&gt;% pivot_longer( cols = 5:ncol(.), names_to = &quot;date&quot;, values_to = &quot;cases&quot; ) %&gt;% # mutate(date = as.Date(date, &quot;%m/%d/%y&quot;)) #%&gt;% mutate(date = lubridate::mdy(date)) %&gt;% janitor::clean_names() %&gt;% group_by(country_region, date) %&gt;% summarise(cases = sum(cases)) d1 d1 %&gt;% distinct(country_region) d1 %&gt;% filter(country_region == &quot;China&quot;) d1 %&gt;% filter(country_region == &quot;China&quot;) %&gt;% ggplot(aes(x = date, y = cases)) + geom_point() + scale_x_date(date_breaks = &quot;1 week&quot;, date_labels = &quot;%m-%d&quot;) 12.2 可视化探索 d %&gt;% gather(date, cases, 5:ncol(.)) %&gt;% mutate(date = as.Date(date, &quot;%m/%d/%y&quot;)) %&gt;% group_by(country = `Country/Region`, date) %&gt;% summarise(cases = sum(cases)) %&gt;% filter(country != &quot;Others&quot; &amp; country != &quot;Mainland China&quot;) %&gt;% bind_rows( tibble(country = &quot;Republic of Korea&quot;, date = as.Date(&quot;2020-03-11&quot;), cases = 7755) ) %&gt;% group_by(country) %&gt;% mutate(days_since_100 = as.numeric(date - min(date[cases &gt;= 100]))) %&gt;% ungroup() %&gt;% filter(is.finite(days_since_100)) %&gt;% group_by(country) %&gt;% mutate(new_cases = cases - cases[days_since_100 == 0]) %&gt;% filter(sum(cases &gt;= 100) &gt;= 5) %&gt;% filter(cases &gt;= 100) %&gt;% bind_rows( tibble(country = &quot;33% daily rise&quot;, days_since_100 = 0:18) %&gt;% mutate(cases = 100 * 1.33^days_since_100) ) %&gt;% ungroup() %&gt;% mutate( country = country %&gt;% str_replace_all(&quot;( SAR)|( \\\\(.+)|(Republic of )&quot;, &quot;&quot;) ) %&gt;% # filter(days_since_100 &lt;= 10) %&gt;% ggplot(aes(days_since_100, cases, col = country)) + geom_hline(yintercept = 100) + geom_vline(xintercept = 0) + geom_line(size = 0.8) + geom_point(pch = 21, size = 1) + scale_y_log10(expand = expand_scale(add = c(0, 0.1)), breaks = c(100, 200, 500, 1000, 2000, 5000, 10000)) + # scale_y_continuous(expand = expand_scale(add = c(0,100))) + scale_x_continuous(expand = expand_scale(add = c(0, 1))) + theme_minimal() + theme( panel.grid.minor = element_blank(), legend.position = &quot;none&quot;, plot.margin = margin(3, 15, 3, 3, &quot;mm&quot;) ) + coord_cartesian(clip = &quot;off&quot;) + geom_shadowtext(aes(label = paste0(&quot; &quot;, country)), hjust = 0, vjust = 0, data = . %&gt;% group_by(country) %&gt;% top_n(1, days_since_100), bg.color = &quot;white&quot;) + labs(x = &quot;Number of days since 100th case&quot;, y = &quot;&quot;, subtitle = &quot;Total number of cases&quot;) 12.3 地图 Map Visualization of COVID-19 Across the World with R world &lt;- map_data(&quot;world&quot;) # cutoffs based on the number of cases mybreaks &lt;- c(1, 20, 100, 1000, 50000) ggplot() + geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = &quot;grey&quot;, alpha = 0.3) + geom_point(data = d, aes(x = Long, y = Lat, size = `3/3/20`, color = `3/3/20`), stroke = F, alpha = 0.7) + scale_size_continuous(name = &quot;Cases&quot;, trans = &quot;log&quot;, range = c(1, 7), breaks = mybreaks, labels = c(&quot;1-19&quot;, &quot;20-99&quot;, &quot;100-999&quot;, &quot;1,000-49,999&quot;, &quot;50,000+&quot;)) + # scale_alpha_continuous(name=&quot;Cases&quot;, trans=&quot;log&quot;, range=c(0.1, 0.9),breaks=mybreaks) + scale_color_viridis_c(option = &quot;inferno&quot;, name = &quot;Cases&quot;, trans = &quot;log&quot;, breaks = mybreaks, labels = c(&quot;1-19&quot;, &quot;20-99&quot;, &quot;100-999&quot;, &quot;1,000-49,999&quot;, &quot;50,000+&quot;)) + theme_void() + guides(colour = guide_legend()) + labs(caption = &quot;Data Repository provided by Johns Hopkins CSSE. Visualization by DataScience+ &quot;) + theme( legend.position = &quot;bottom&quot;, text = element_text(color = &quot;#22211d&quot;), plot.background = element_rect(fill = &quot;#ffffff&quot;, color = NA), panel.background = element_rect(fill = &quot;#ffffff&quot;, color = NA), legend.background = element_rect(fill = &quot;#ffffff&quot;, color = NA) ) 12.4 更多 "],
["ggplot2.html", "第 13 章 ggplot2 13.1 一个有趣的案例 13.2 学习目标 13.3 开始 13.4 基本绘图 13.5 主题风格 13.6 定制 13.7 组合图片 13.8 中文字体 13.9 高亮某一组 13.10 函数图 13.11 地图 13.12 参考资料", " 第 13 章 ggplot2 采菊东篱下，悠然见南山。 根据大家投票，觉得ggplot2是最想掌握的技能，我想这就是R语言中最有质感的部分吧。所以，这里专门拿出一节课讲ggplot2，也算是补上之前第 7 章数据可视化没讲的内容。 有几个新的宏包需要提前安装（不是必须的） install.packages(c(&quot;sf&quot;, &quot;cowplot&quot;, &quot;patchwork&quot;, &quot;gghighlight&quot;)) 如果安装不成功，请先update宏包，再执行上面安装命令 library(tidyverse) library(gghighlight) library(cowplot) library(patchwork) 13.1 一个有趣的案例 先看一组数据 df &lt;- read_csv(&quot;./demo_data/datasaurus.csv&quot;) df 先用dataset分组后，然后计算每组下x的均值和方差，y的均值和方差，以及x，y两者的相关系数，我们发现每组数据下它们几乎都是相等的 df %&gt;% group_by(dataset) %&gt;% summarise_all(list(mean, sd)) %&gt;% mutate_if(is.numeric, round, 3) 如果上面代码不熟悉，可以用第 6 章的代码重新表达，也是一样的 df %&gt;% group_by(dataset) %&gt;% summarize( mean_x = mean(x), mean_y = mean(y), std_dev_x = sd(x), std_dev_y = sd(y), corr_x_y = cor(x, y) ) 那么，我们是否能得出结论，每组的数据长的差不多呢？然而，我们画图发现 ggplot(df, aes(x = x, y = y, colour = dataset)) + geom_point() + # geom_smooth(method = lm) + theme(legend.position = &quot;none&quot;) + facet_wrap(~dataset, ncol = 3) 事实上，每张图都相差很大。所以，这里想说明的是，眼见为实。换句话说，可视化是数据探索中非常重要的部分。本章的目的就是带领大家学习ggplot2基本的绘图技能。 13.2 学习目标 Grammer of Graphics data: 数据框data.frame (注意，不支持向量vector和列表list类型） aes: 数据框中的变量映射到图形属性。什么叫图形属性？就是图中点的位置、形状，大小，颜色等眼睛能看到的东西。什么叫映射？就是一种对应关系，比如数学中的函数b = f(a)就是a和b之间的一种映射关系, a的值决定或者控制了b的值，在ggplot2语法里，a就是我们输入的数据变量，b就是图形属性， 这些图形属性包括： x（x轴方向的位置） y（y轴方向的位置） color（点或者线等元素的颜色） size（点或者线等元素的大小） shape（点或者线等元素的形状） alpha（点或者线等元素的透明度） geoms: 几何对象，确定我们想画什么样的图，一个geom_***确定一种图形。更多几何对象推荐阅读这里 geom_bar() geom_density() geom_freqpoly() geom_histogram() geom_violin() geom_boxplot() geom_col() geom_point() geom_smooth() geom_tile() geom_density2d() geom_bin2d() geom_hex() geom_count() geom_text() geom_sf() stats: 统计变换 scales: 标度 coord: 坐标系统 facet: 分面 layer： 增加图层 theme: 主题风格 save: 保存图片 13.3 开始 前面讲到R语言数据类型有字符串型、数值型、因子型、逻辑型、日期型等，ggplot2会将字符串型、因子型、逻辑型、日期型默认为离散变量，而数值型默认为连续变量。我们在而呈现数据的时候，可能会同时用到多种类型的数据，比如 一个离散 一个连续 两个离散 两个连续 一个离散, 一个连续 三个连续 13.3.1 导入数据 gapdata &lt;- read_csv(&quot;./demo_data/gapminder.csv&quot;) gapdata 13.3.2 检查数据 # 是否有缺失值 gapdata %&gt;% summarise_all(~ any(is.na(.))) country 代表国家 countinet 表示所在的洲 year 时间 lifeExp 平均寿命 pop 人口数量 gdpPercap 人均GDP 接下来，我们需要思考我们应该选择什么样的图，呈现这些不同类型的数据，探索数据背后的故事 13.4 基本绘图 13.4.1 柱状图 常用于一个离散变量 gapdata %&gt;% ggplot(aes(x = continent)) + geom_bar() gapdata %&gt;% ggplot(aes(x = reorder(continent, continent, length))) + geom_bar() gapdata %&gt;% ggplot(aes(x = reorder(continent, continent, length))) + geom_bar() + coord_flip() # geom_bar vs stat_count gapdata %&gt;% ggplot(aes(x = continent)) + stat_count() gapdata %&gt;% count(continent) 可见，geom_bar() 自动完成了这个统计，更多geom与stat对应关系见这里 gapdata %&gt;% distinct(continent, country) %&gt;% ggplot(aes(x = continent)) + geom_bar() 我个人比较喜欢先统计，然后画图 gapdata %&gt;% distinct(continent, country) %&gt;% group_by(continent) %&gt;% summarise(num = n()) %&gt;% ggplot(aes(x = continent, y = num)) + geom_col() 13.4.2 直方图 常用于一个连续变量 gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_histogram() # 对应的stat_bin() gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_histogram(binwidth = 1) #&#39; histograms, 默认使用 `position = &quot;stack&quot;` gapdata %&gt;% ggplot(aes(x = lifeExp, fill = continent)) + geom_histogram() #&#39; 使用`position = &quot;identity&quot;` gapdata %&gt;% ggplot(aes(x = lifeExp, fill = continent)) + geom_histogram(position = &quot;identity&quot;) gapdata %&gt;% ggplot(aes(x = lifeExp, color = continent)) + geom_freqpoly() #&#39; smooth histogram = densityplot gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_density() 如果不喜欢下面那条线，可以这样 gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_line(stat = &quot;density&quot;) # adjust 调节bandwidth, # adjust = 1/2 means use half of the default bandwidth. gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_density(adjust = 1) gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_density(adjust = 0.2) gapdata %&gt;% ggplot(aes(x = lifeExp, color = continent)) + geom_density() gapdata %&gt;% ggplot(aes(x = lifeExp, fill = continent)) + geom_density(alpha = 0.2) gapdata %&gt;% filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = lifeExp, fill = continent)) + geom_density(alpha = 0.2) gapdata %&gt;% ggplot(aes(x = lifeExp)) + geom_density() + # facet_wrap(vars(continent)) facet_grid(. ~ continent) gapdata %&gt;% filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = lifeExp, fill = continent)) + geom_histogram() + facet_grid(continent ~ .) 直方图和密度图画在一起。注意y = stat(density)表示y是由x新生成的变量，这是一种固定写法，类似的还有stat(count), stat(level) gapdata %&gt;% filter(continent != &quot;Oceania&quot;) %&gt;% ggplot(aes(x = lifeExp, y = stat(density))) + geom_histogram(aes(fill = continent)) + geom_density() + facet_grid(continent ~ .) 13.4.3 箱线图 一个离散变量 + 一个连续变量 #&#39; 思考下结果为什么是这样？ gapdata %&gt;% ggplot(aes(x = year, y = lifeExp)) + geom_boxplot() # 数据框中的year变量是数值型，需要先转换成因子型，弄成离散型变量 gapdata %&gt;% ggplot(aes(x = as.factor(year), y = lifeExp)) + geom_boxplot() # 明确指定分组变量 gapdata %&gt;% ggplot(aes(x = year, y = lifeExp)) + geom_boxplot(aes(group = year)) gapdata %&gt;% ggplot(aes(x = year, y = lifeExp)) + geom_violin(aes(group = year)) + geom_jitter(alpha = 1 / 4) + geom_smooth(se = FALSE) 13.4.4 抖散图 点重叠的处理方案 gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_point() gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_jitter() gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_boxplot() gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_boxplot() + geom_jitter() gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_jitter() + stat_summary(fun.y = median, colour = &quot;red&quot;, geom = &quot;point&quot;, size = 5) gapdata %&gt;% ggplot(aes(reorder(x = continent, lifeExp), y = lifeExp)) + geom_jitter() + stat_summary(fun.y = median, colour = &quot;red&quot;, geom = &quot;point&quot;, size = 5) gapdata %&gt;% ggplot(aes(x = continent, y = lifeExp)) + geom_violin( trim = FALSE, alpha = 0.5 ) + stat_summary( fun.y = mean, fun.ymax = function(x) { mean(x) + sd(x) }, fun.ymin = function(x) { mean(x) - sd(x) }, geom = &quot;pointrange&quot; ) 13.4.5 山峦图 常用于一个离散变量 + 一个连续变量 gapdata %&gt;% ggplot(aes(x = lifeExp, y = continent, fill = continent)) + ggridges::geom_density_ridges() 13.4.6 散点图 常用于两个连续变量 gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() gapdata %&gt;% ggplot(aes(x = log(gdpPercap), y = lifeExp)) + geom_point() gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + scale_x_log10() # A better way to log transform gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes(color = continent)) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(alpha = (1 / 3), size = 2) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + geom_smooth() gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + geom_smooth(lwd = 3, se = FALSE) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point(show.legend = FALSE) + facet_wrap(~continent) jCountries &lt;- c(&quot;Canada&quot;, &quot;Rwanda&quot;, &quot;Cambodia&quot;, &quot;Mexico&quot;) gapdata %&gt;% filter(country %in% jCountries) %&gt;% ggplot(aes(x = year, y = lifeExp, color = country)) + geom_line() + geom_point() gapdata %&gt;% filter(country %in% jCountries) %&gt;% ggplot(aes( x = year, y = lifeExp, color = reorder(country, -1 * lifeExp, max) )) + geom_line() + geom_point() 13.4.7 点线图 gapdata %&gt;% filter(continent == &quot;Asia&quot; &amp; year == 2007) %&gt;% ggplot(aes(x = lifeExp, y = country)) + geom_point() gapdata %&gt;% filter(continent == &quot;Asia&quot; &amp; year == 2007) %&gt;% ggplot(aes( x = lifeExp, y = reorder(country, lifeExp) )) + geom_point(color = &quot;blue&quot;, size = 2) + geom_segment(aes( x = 40, xend = lifeExp, y = reorder(country, lifeExp), yend = reorder(country, lifeExp) ), color = &quot;lightgrey&quot; ) + labs( x = &quot;Life Expectancy (years)&quot;, y = &quot;&quot;, title = &quot;Life Expectancy by Country&quot;, subtitle = &quot;GapMinder data for Asia - 2007&quot; ) + theme_minimal() + theme( panel.grid.major = element_blank(), panel.grid.minor = element_blank() ) 13.4.8 文本标注 ten_countries &lt;- gapdata %&gt;% distinct(country) %&gt;% pull() %&gt;% sample(10) library(ggrepel) gapdata %&gt;% filter(year == 2007) %&gt;% mutate( label = ifelse(country %in% ten_countries, as.character(country), &quot;&quot;) ) %&gt;% ggplot(aes(log(gdpPercap), lifeExp)) + geom_point( size = 3.5, alpha = .9, shape = 21, col = &quot;white&quot;, fill = &quot;#0162B2&quot; ) + geom_text_repel( aes(label = label), size = 4.5, point.padding = .2, box.padding = .3, force = 1, min.segment.length = 0 ) + theme_minimal(14) + theme( legend.position = &quot;none&quot;, panel.grid.minor = element_blank() ) + labs( x = &quot;log(GDP per capita)&quot;, y = &quot;life expectancy&quot; ) 13.4.9 errorbar图 avg_gapdata &lt;- gapdata %&gt;% group_by(continent) %&gt;% summarise( mean = mean(lifeExp), sd = sd(lifeExp) ) avg_gapdata avg_gapdata %&gt;% ggplot(aes(continent, mean, fill = continent)) + # geom_col(alpha = 0.5) + geom_point() + geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.25) 13.4.10 椭圆图 gapdata %&gt;% ggplot(aes(x = log(gdpPercap), y = lifeExp)) + geom_point() + stat_ellipse(type = &quot;norm&quot;, level = 0.95) 13.4.11 2D 密度图 与一维的情形geom_density()类似， geom_density_2d(), geom_bin2d(), geom_hex()常用于刻画两个变量构成的二维区间的密度 gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_bin2d() gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_hex() 13.4.12 马赛克图 geom_tile()， geom_contour()， geom_raster()常用于3个变量 gapdata %&gt;% group_by(continent, year) %&gt;% summarise(mean_lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = year, y = continent, fill = mean_lifeExp)) + geom_tile() + scale_fill_viridis_c() 事实上可以有更好的呈现方式 gapdata %&gt;% group_by(continent, year) %&gt;% summarise(mean_lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = year, y = continent, size = mean_lifeExp)) + geom_point() gapdata %&gt;% group_by(continent, year) %&gt;% summarise(mean_lifeExp = mean(lifeExp)) %&gt;% ggplot(aes(x = year, y = continent, size = mean_lifeExp)) + geom_point(shape = 21, color = &quot;red&quot;, fill = &quot;white&quot;) + scale_size_continuous(range = c(7, 15)) + geom_text(aes(label = round(mean_lifeExp, 2)), size = 3, color = &quot;black&quot;) + theme(legend.position = &quot;none&quot;) 13.5 主题风格 gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggtitle(&quot;Life expectancy over time by continent&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + theme_grey() # the default gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + theme_bw() gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_calc() + ggtitle(&quot;ggthemes::theme_calc()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_economist() + ggtitle(&quot;ggthemes::theme_economist()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_economist_white() + ggtitle(&quot;ggthemes::theme_economist_white()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_few() + ggtitle(&quot;ggthemes::theme_few()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_gdocs() + ggtitle(&quot;ggthemes::theme_gdocs()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_tufte() + ggtitle(&quot;ggthemes::theme_tufte()&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + geom_smooth(lwd = 3, se = FALSE, method = &quot;lm&quot;) + ggthemes::theme_wsj() + ggtitle(&quot;ggthemes::theme_wsj()&quot;) 13.6 定制 13.6.1 Labels gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + ggtitle(&quot;My Plot Title&quot;) + xlab(&quot;The X Variable&quot;) + ylab(&quot;The Y Variable&quot;) gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + labs( title = &quot;My Plot Title&quot;, subtitle = &quot;My Plot subtitle&quot;, x = &quot;The X Variable&quot;, y = &quot;The Y Variable&quot; ) 13.6.2 定制颜色 我喜欢用这两个函数定制喜欢的绘图色彩，scale_colour_manual() 和 scale_fill_manual(). 更多方法可以参考 Colours chapter in Cookbook for R gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + scale_color_manual( values = c(&quot;#195744&quot;, &quot;#008148&quot;, &quot;#C6C013&quot;, &quot;#EF8A17&quot;, &quot;#EF2917&quot;) ) 13.7 组合图片 我们有时候想把多张图组合到一起 13.7.1 cowplot 可以使用 cowplot 宏包的plot_grid()函数完成多张图片的组合，使用方法很简单。 p1 &lt;- gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point(aes(color = lifeExp &gt; mean(lifeExp))) + scale_x_log10() + theme(legend.position = &quot;none&quot;) + scale_color_manual(values = c(&quot;orange&quot;, &quot;pink&quot;)) + labs( title = &quot;My Plot Title&quot;, x = &quot;The X Variable&quot;, y = &quot;The Y Variable&quot; ) p2 &lt;- gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + scale_color_manual( values = c(&quot;#195744&quot;, &quot;#008148&quot;, &quot;#C6C013&quot;, &quot;#EF8A17&quot;, &quot;#EF2917&quot;) ) + theme(legend.position = &quot;none&quot;) + labs( title = &quot;My Plot Title&quot;, x = &quot;The X Variable&quot;, y = &quot;The Y Variable&quot; ) cowplot::plot_grid( p1, p2, labels = c(&quot;A&quot;, &quot;B&quot;) ) 也可以使用patchwork宏包，更简单的方法 library(patchwork) p1 + p2 p1 / p2 p1 + p2 + plot_annotation( tag_levels = &#39;A&#39;, title = &#39;The surprising truth about mtcars&#39;, subtitle = &#39;These 3 plots will reveal yet-untold secrets about our beloved data-set&#39;, caption = &#39;Disclaimer: None of these plots are insightful&#39; ) patchwork 使用方法很简单，根本不需要记 13.7.2 保存图片 使用ggsave()函数，将图片保存为所需要的格式，如“.pdf”, “.png”等， 还可以指定图片的高度和宽度，默认units是英寸，也可以使用“cm”, or “mm”. pp &lt;- gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + scale_color_manual( values = c(&quot;#195744&quot;, &quot;#008148&quot;, &quot;#C6C013&quot;, &quot;#EF8A17&quot;, &quot;#EF2917&quot;) ) + theme(legend.position = &quot;none&quot;) + labs( title = &quot;My Plot Title&quot;, x = &quot;The X Variable&quot;, y = &quot;The Y Variable&quot; ) # ggsave(&quot;demo_plot.pdf&quot;, plot = pp, width = 8, height = 6) 13.8 中文字体 library(showtext) showtext_auto() gapdata %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp, color = continent)) + geom_point() + scale_x_log10() + scale_color_manual( values = c(&quot;#195744&quot;, &quot;#008148&quot;, &quot;#C6C013&quot;, &quot;#EF8A17&quot;, &quot;#EF2917&quot;) ) + theme(legend.position = &quot;none&quot;) + labs( title = &quot;这是我的标题美美哒&quot;, x = &quot;这是我的x坐标&quot;, y = &quot;这是我的y坐标&quot; ) # ggsave(&quot;myfirst.pdf&quot;, width = 8, height = 6) 13.9 高亮某一组 画图很容易，然而画一张好图，不容易。图片质量好不好，其原则就是不增加看图者的心智负担，有些图片的色彩很丰富，然而需要看图人配合文字和图注等信息才能看懂作者想表达的意思，这样就失去了图片“一图胜千言”的价值。 分析数据过程中，我们可以使用高亮我们某组数据，突出我们想表达的信息，是非常好的一种可视化探索手段。 13.9.1 ggplot2方法 这种方法是将背景部分和高亮部分分两步来画 drop_facet &lt;- function(x) select(x, -continent) gapdata %&gt;% ggplot() + geom_line( data = drop_facet, aes(x = year, y = lifeExp, group = country), color = &quot;grey&quot;, ) + geom_line(aes(x = year, y = lifeExp, color = country, group = country)) + facet_wrap(vars(continent)) + theme(legend.position = &quot;none&quot;) 再来一个 gapdata %&gt;% mutate(group = country) %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% ggplot() + geom_line( data = function(d) select(d, -country), aes(x = year, y = lifeExp, group = group), color = &quot;grey&quot;, ) + geom_line(aes(x = year, y = lifeExp, group = country), color = &quot;red&quot;) + facet_wrap(vars(country)) + theme(legend.position = &quot;none&quot;) 13.9.2 gghighlight方法 这里推荐gghighlight宏包 dplyr has filter() ggplot has Highlighting gapdata %&gt;% filter(country == &quot;China&quot;) gapdata %&gt;% ggplot( aes(x = year, y = lifeExp, color = continent, group = country) ) + geom_line() + gghighlight( country == &quot;China&quot;, # which is passed to dplyr::filter(). label_key = country ) gapdata %&gt;% filter(continent == &quot;Asia&quot;) gapdata %&gt;% filter(continent == &quot;Asia&quot;) %&gt;% ggplot(aes(year, lifeExp, color = country, group = country)) + geom_line(size = 1.2, alpha = .9, color = &quot;#E58C23&quot;) + theme_minimal(base_size = 14) + theme( legend.position = &quot;none&quot;, panel.grid.major.x = element_blank(), panel.grid.minor = element_blank() ) + gghighlight( country %in% c(&quot;China&quot;, &quot;India&quot;, &quot;Japan&quot;, &quot;Korea, Rep.&quot;), use_group_by = FALSE, use_direct_label = FALSE, unhighlighted_params = list(color = &quot;grey90&quot;) ) + facet_wrap(vars(country)) 13.10 函数图 有时候我们想画一个函数图，比如正态分布的函数，可能会想到先产生数据，然后画图，比如下面的代码 tibble(x = seq(from = -3, to = 3, by = .01)) %&gt;% mutate(y = dnorm(x, mean = 0, sd = 1)) %&gt;% ggplot(aes(x = x, y = y)) + geom_line(color = &quot;grey33&quot;) 事实上，stat_function()可以简化这个过程 ggplot(data = data.frame(x = c(-3, 3)), aes(x = x)) + stat_function(fun = dnorm) 当然我们也可以绘制自定义函数 myfun &lt;- function(x) { (x - 1)**2 } ggplot(data = data.frame(x = c(-1, 3)), aes(x = x)) + stat_function(fun = myfun, geom = &quot;line&quot;, colour = &quot;red&quot;) 下面这是一个很不错的例子，细细体会下 d &lt;- tibble(x = rnorm(2000, mean = 2, sd = 4)) ggplot(data = d, aes(x = x)) + geom_histogram(aes(y = stat(density))) + geom_density() + stat_function(fun = dnorm, args = list(mean = 2, sd = 4), colour = &quot;red&quot;) 13.11 地图 小时候画地图很容易，长大了画地图却不容易了。 这是一个公园🏞地图和公园里松鼠🐿数量的数据集 nyc_squirrels &lt;- read_csv(&quot;./demo_data/nyc_squirrels.csv&quot;) central_park &lt;- sf::read_sf(&quot;./demo_data/central_park&quot;) 先来一个地图， ggplot() + geom_sf(data = central_park) 一个geom_sf就搞定了🥂，貌似没那么难呢？ 好吧，换个姿势，在地图上标注松鼠出现的位置 nyc_squirrels %&gt;% drop_na(primary_fur_color) %&gt;% ggplot() + geom_sf(data = central_park, color = &quot;grey85&quot;) + geom_point( aes(x = long, y = lat, color = primary_fur_color), size = .8 ) 分开画呢 nyc_squirrels %&gt;% drop_na(primary_fur_color) %&gt;% ggplot() + geom_sf(data = central_park, color = &quot;grey85&quot;) + geom_point( aes(x = long, y = lat, color = primary_fur_color), size = .8 ) + facet_wrap(vars(primary_fur_color)) + theme(legend.position = &quot;none&quot;) label_colors &lt;- c(&quot;all squirrels&quot; = &quot;grey75&quot;, &quot;highlighted group&quot; = &quot;#0072B2&quot;) nyc_squirrels %&gt;% drop_na(primary_fur_color) %&gt;% ggplot() + geom_sf(data = central_park, color = &quot;grey85&quot;) + geom_point( data = function(x) select(x, -primary_fur_color), aes(x = long, y = lat, color = &quot;all squirrels&quot;), size = .8 ) + geom_point( aes(x = long, y = lat, color = &quot;highlighted group&quot;), size = .8 ) + cowplot::theme_map(16) + theme( legend.position = &quot;bottom&quot;, legend.justification = &quot;center&quot; ) + facet_wrap(vars(primary_fur_color)) + scale_color_manual(name = NULL, values = label_colors) + guides(color = guide_legend(override.aes = list(size = 2))) # ggsave(&quot;Squirrels.pdf&quot;, width = 9, height = 6) 当然，也可以用gghighlight的方法 nyc_squirrels %&gt;% drop_na(primary_fur_color) %&gt;% ggplot() + geom_sf(data = central_park, color = &quot;grey85&quot;) + geom_point( aes(x = long, y = lat, color = primary_fur_color), size = .8 ) + gghighlight( label_key = primary_fur_color, use_direct_label = FALSE ) + facet_wrap(vars(primary_fur_color)) + cowplot::theme_map(16) + theme(legend.position = &quot;none&quot;) library(ggplot2) library(showtext) showtext_auto() font_families() ## [1] &quot;sans&quot; &quot;serif&quot; &quot;mono&quot; ## [4] &quot;wqy-microhei&quot; font_paths() ## [1] &quot;C:\\\\Windows\\\\Fonts&quot; font_files() ## Add fonts that are available on Windows(默认路径&quot;C:\\\\Windows\\\\Fonts&quot;) font_add(&quot;heiti&quot;, &quot;simhei.ttf&quot;) font_add(&quot;constan&quot;, &quot;constan.ttf&quot;, italic = &quot;constani.ttf&quot;) font_add(&quot;kaishu&quot;, &quot;simkai.ttf&quot;) #font_add(&quot;Noto&quot;, &quot;NotoSansCJKsc-Regular.otf&quot;) font_add(&quot;Yahei&quot;, &quot;Yahei.ttf&quot;) # 也可放在指定的目录(尽量英文) # https://github.com/yixuan/showtext/issues/18 font_add(&quot;fzfsj&quot;, here::here(&quot;myfont&quot;, &quot;fzfsj.ttf&quot;)) font_add(&quot;fzxbsj&quot;, here::here(&quot;myfont&quot;, &quot;FZXBSJW.ttf&quot;)) font_add(&quot;maoti&quot;, here::here(&quot;myfont&quot;, &quot;maoti.ttf&quot;)) font_add(&quot;fzshuliu&quot;, here::here(&quot;myfont&quot;, &quot;fzshuliu.ttf&quot;)) font_families() ## [1] &quot;sans&quot; &quot;serif&quot; &quot;mono&quot; ## [4] &quot;wqy-microhei&quot; &quot;heiti&quot; &quot;constan&quot; ## [7] &quot;kaishu&quot; &quot;Yahei&quot; &quot;fzfsj&quot; ## [10] &quot;fzxbsj&quot; &quot;maoti&quot; &quot;fzshuliu&quot; ## maybe, 保存为pdf图，才能看到有效字体 ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + ggtitle(&quot;这是我的小标宋简体&quot;) + theme( plot.title = element_text(family = &quot;fzxbsj&quot;) ) + geom_text(aes(x = 5, y = 40), label = &quot;方正仿宋简体&quot;, family = &quot;fzfsj&quot;) + geom_text(aes(x = 5, y = 38), label = &quot;这是我的雅黑&quot;, family = &quot;Yahei&quot;) + geom_text(aes(x = 5, y = 35), label = &quot;方正楷书简体&quot;, family = &quot;kaishu&quot;) + geom_text(aes(x = 5, y = 30), label = &quot;草檀斋毛泽东字体&quot;, family = &quot;maoti&quot;) + geom_text(aes(x = 5, y = 28), label = &quot;方正苏新诗柳楷简体&quot;, family = &quot;fzshuliu&quot;) #ggsave(&quot;showtext-example-9.pdf&quot;, width = 7, height = 4, dpi = 200) 根据往年大家提交的作业，有同学用rmarkdown生成pdf，图片标题使用了中文字体，但中文字体无法显示 。解决方案是R code chunks加上fig.showtext=TRUE ```{r, fig.showtext=TRUE} 详细资料可参考这里 13.11.1 latex公式 library(ggplot2) library(latex2exp) ggplot(mpg, aes(x = displ, y = hwy)) + geom_point() + annotate(&quot;text&quot;, x = 4, y = 40, label = TeX(&quot;$\\\\alpha^2 + \\\\theta^2 = \\\\omega^2 $&quot;), size = 9) + labs(title = TeX(&quot;The ratio of 1 and 2 is $\\\\,\\\\, \\\\frac{1}{2}$&quot;), x = TeX(&quot;$\\\\alpha$&quot;), y = TeX(&quot;$\\\\alpha^2$&quot;) ) 13.12 参考资料 Look at Data from Data Vizualization for Social Science Chapter 3: Data Visualisation of R for Data Science Chapter 28: Graphics for communication of R for Data Science Graphs in R Graphics Cookbook ggplot2 cheat sheet ggplot2 documentation The R Graph Gallery (this is really useful) Top 50 ggplot2 Visualizations R Graphics Cookbook by Winston Chang ggplot extensions plotly for creating interactive graphs "],
["tips.html", "第 14 章 tidyverse中的若干技巧 14.1 From gather() to pivot() 14.2 count() 14.3 在 count() 中创建新变量 14.4 add_count() 14.5 nth(), first(), last() 14.6 列变量重新排序 14.7 if_else 14.8 case_when 14.9 找出前几名 14.10 drop_na() 14.11 replace_na() 14.12 coalesce 14.13 summarise() 生成 list-column 14.14 count() + fct_reorder() + geom_col() + coord_flip() 14.15 scale_x/y_log10 14.16 fct_lump 14.17 unite 14.18 separate() 14.19 extract() 14.20 crossing()", " 第 14 章 tidyverse中的若干技巧 聊聊tidyverse中常用的一些小技巧 “most of data science is counting, and sometimes dividing” — Hadley Wickham library(tidyverse) library(patchwork) # install.packages(&quot;patchwork&quot;) 14.1 From gather() to pivot() make data tidy VARIABLE, OBSERVATION, VALUE Each variable is a column Each observation is a row Each type of observational unit is a table plant_heigt &lt;- data.frame( Day = 1:5, A = c(0.7, 1.0, 1.5, 1.8, 2.2), B = c(0.5, 0.7, 0.9, 1.3, 1.8) ) plant_heigt 大家想想， 把植物高度大于或等于0.8cm的筛选出来，怎么写语句? 用不同的颜色画出两种植物生长曲线，怎么写语句? plant_heigt %&gt;% filter( ___ &gt;= 0.8) plant_heigt %&gt;% ggplot(aes(x = Day, y = ___, color = ___)) + geom_line() 想用上面的语句，数据就得变形。那么怎么变形呢？ 从2019年9月份，tidyr 1.0.0新增了一组函数pivot_longer()/pivot_wider()，用来补充和完善原来的gather()/spread() gather()/pivot_longer it makes “wide” data longer. spread()/pivot_wider it makes “long” data wider. 所以现在使用pivot_longer()函数 long &lt;- pivot_longer(plant_heigt, 2:3, names_to = &quot;plant&quot;, values_to = &quot;height&quot; ) long plant_heigt %&gt;% pivot_longer( cols = -Day, # A:B 或者 c(A, B) 或者 c(&quot;A&quot;, &quot;B&quot;) names_to = &quot;plant&quot;, values_to = &quot;height&quot; ) long %&gt;% ggplot(aes(x = Day, y = height, color = plant)) + geom_line() wide &lt;- long %&gt;% pivot_wider( names_from = &quot;plant&quot;, values_from = &quot;height&quot; ) wide 14.2 count() 我之前多次用到count()函数，其功能就是统计某个变量中各组出现的次数 df &lt;- tibble( name = c(&quot;Alice&quot;, &quot;Alice&quot;, &quot;Bob&quot;, &quot;Bob&quot;, &quot;Carol&quot;, &quot;Carol&quot;), type = c(&quot;english&quot;, &quot;math&quot;, &quot;english&quot;, &quot;math&quot;, &quot;english&quot;, &quot;math&quot;), score = c(60.2, 90.5, 92.2, 98.8, 82.5, 74.6) ) df df %&gt;% count(name) 如果用之前讲的group_by() + summarise()来写， df %&gt;% group_by(name) %&gt;% summarise( n = n()) count() 还有更多强大的参数， 比如 df %&gt;% count(name, sort = TRUE, wt = score, name = &quot;total_score&quot; ) 如果不用count()，用group_by() + summarise()写， df %&gt;% group_by(name) %&gt;% summarise( n = n(), total_score = sum(score, na.rm = TRUE) ) %&gt;% arrange(desc(total_score)) 当然，count()在特定场合下的简便写法，遇到复杂的分组统计，还是得用用group_by() + summarise()组合。 14.3 在 count() 中创建新变量 可以在count()里构建新变量，并利用这个新变量完成统计 df %&gt;% count(range = 10 * (score %/% 10)) 14.4 add_count() 想增加一列，代表每人参加的考试次数 df %&gt;% group_by(name) %&gt;% mutate(n = n()) %&gt;% ungroup() 可以有更简单的方法 df %&gt;% add_count(name) 14.5 nth(), first(), last() v &lt;- c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;k&quot;) v[1] ## [1] &quot;a&quot; v[length(v)] ## [1] &quot;k&quot; c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;k&quot;) %&gt;% nth(3) ## [1] &quot;d&quot; c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;k&quot;) %&gt;% first() ## [1] &quot;a&quot; c(&quot;a&quot;, &quot;c&quot;, &quot;d&quot;, &quot;k&quot;) %&gt;% last() ## [1] &quot;k&quot; 用在数据框中，同样可以使用 df %&gt;% filter(score == first(score)) df %&gt;% group_by(name) %&gt;% filter(score == last(score)) 14.6 列变量重新排序 比如想把score放在第一列 df %&gt;% select(score, everything()) 这个方法，对列变量较多的情形非常适用。 14.7 if_else df %&gt;% mutate( assess = if_else(score &gt; 85, &quot;very_good&quot;, &quot;good&quot;) ) 14.8 case_when df %&gt;% mutate( assess = case_when( score &lt; 70 ~ &quot;general&quot;, score &gt;= 70 &amp; score &lt; 80 ~ &quot;good&quot;, score &gt;= 80 &amp; score &lt; 90 ~ &quot;very_good&quot;, score &gt;= 90 ~ &quot;best&quot;, TRUE ~ &quot;other&quot; ) ) 14.9 找出前几名 df %&gt;% top_n(2, score) 14.10 drop_na() dt &lt;- tribble( ~x, ~y, 1, NA, 2, NA, NA, -3, NA, -4, 5, -5 ) dt dt %&gt;% drop_na() # dt %&gt;% drop_na(x) 14.11 replace_na() dt &lt;- tribble( ~x, ~y, 1, NA, 2, NA, NA, -3, NA, -4, 5, -5 ) dt %&gt;% mutate(x = replace_na(x, 0)) dt %&gt;% mutate( x = replace_na(x, mean(x, na.rm = TRUE)) ) 之前讲正则表达式也有类似的函数stringr::str_replace_na()， 14.12 coalesce dt &lt;- tribble( ~x, ~y, 1, NA, 2, NA, NA, -3, NA, -4, 5, -5 ) dt %&gt;% mutate( z = coalesce(x, 0) # z = coalesce(x, y) ) 有时候，我们可能为了减少信息丢失，想填充NA dt &lt;- tribble( ~name, ~age, &quot;a&quot;, 1, &quot;b&quot;, 2, &quot;c&quot;, NA, &quot;d&quot;, 2 ) dt %&gt;% mutate( age_adj = ifelse(is.na(age), mean(age, na.rm = TRUE), age) ) 14.13 summarise() 生成 list-column summarize()会生成一个value， library(gapminder) gapminder %&gt;% group_by(continent) %&gt;% summarise( avg_gdpPercap = mean(gdpPercap) ) summarize()也可以生成一个list， library(gapminder) gapminder %&gt;% group_by(continent) %&gt;% summarise(test = list(t.test(gdpPercap))) %&gt;% # 单样本的t检验 mutate(tidied = purrr::map(test, broom::tidy)) %&gt;% unnest(tidied) %&gt;% ggplot(aes(estimate, continent)) + geom_point() + geom_errorbarh(aes( xmin = conf.low, xmax = conf.high )) gapminder %&gt;% group_by(continent) %&gt;% summarise(test = list(lm(lifeExp ~ gdpPercap))) %&gt;% # 线性回归 mutate(tidied = purrr::map(test, broom::tidy, conf.int = TRUE)) %&gt;% unnest(tidied) %&gt;% filter(term != &quot;(Intercept)&quot;) %&gt;% ggplot(aes(estimate, continent)) + geom_point() + geom_errorbarh(aes( xmin = conf.low, xmax = conf.high, height = .3 )) 以下两种方法，同样完成上面的工作，具体方法会在第 21 章介绍 gapminder %&gt;% group_nest(continent) %&gt;% mutate(test = map(data, ~ t.test(.x$gdpPercap))) %&gt;% mutate(tidied = map(test, broom::tidy)) %&gt;% unnest(tidied) gapminder %&gt;% group_by(continent) %&gt;% group_modify( ~ broom::tidy(t.test(.x$gdpPercap)) ) 14.14 count() + fct_reorder() + geom_col() + coord_flip() 最好用的四件套 gapminder %&gt;% distinct(continent, country) %&gt;% count(continent) %&gt;% ggplot(aes(x = continent, y = n)) + geom_col() gapminder %&gt;% distinct(continent, country) %&gt;% count(continent) %&gt;% ggplot(aes(x = fct_reorder(continent, n), y = n)) + geom_col() + coord_flip() 画图容易，但画出一张好图并不容易 gapminder %&gt;% distinct(continent, country) %&gt;% count(continent) %&gt;% mutate(coll = if_else(continent == &quot;Asia&quot;, &quot;red&quot;, &quot;gray&quot;)) %&gt;% ggplot(aes(x = fct_reorder(continent, n), y = n)) + geom_text(aes(label = n), hjust = -0.25) + geom_col(width = 0.8, aes(fill = coll) ) + coord_flip() + theme_classic() + scale_fill_manual(values = c(&quot;#b3b3b3a0&quot;, &quot;#D55E00&quot;)) + theme(legend.position = &quot;none&quot;, axis.text = element_text(size = 11) ) + labs(title = &quot;我的标题&quot;, x = &quot;&quot;) 或者偷懒，将continent == \"Asia\"的结果直接赋值给aes(fill = ___ )， 效果与上面是一样的。 gapminder %&gt;% distinct(continent, country) %&gt;% count(continent) %&gt;% ggplot(aes(x = fct_reorder(continent, n), y = n)) + geom_text(aes(label = n), hjust = -0.25) + geom_col(width = 0.8, aes(fill = continent == &quot;Asia&quot;) ) + coord_flip() + theme_classic() + scale_fill_manual(values = c(&quot;#b3b3b3a0&quot;, &quot;#D55E00&quot;)) + annotate(&quot;text&quot;, x = 3.8, y = 48, label = &quot;this is important\\ncase&quot;, color = &quot;#D55E00&quot;, size = 5) + annotate( geom = &quot;curve&quot;, x = 4.1, y = 48, xend = 4.1, yend = 35, curvature = .3, arrow = arrow(length = unit(2, &quot;mm&quot;)) ) + theme(legend.position = &quot;none&quot;, axis.text = element_text(size = 11) ) + labs(title = &quot;我的标题&quot;, x = &quot;&quot;) 14.15 scale_x/y_log10 现实世界很多满足对数规则 各国人均GDP 各国人口 不同人士的收入 公司的营业额 gapminder %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() gapminder %&gt;% ggplot(aes(x = gdpPercap, y = lifeExp)) + geom_point() + scale_x_log10() # A better way to log transform 14.16 fct_lump 门诊病症的流水记录 tb &lt;- tibble::tribble( ~disease, ~n, &quot;鼻塞&quot;, 112, &quot;流涕&quot;, 130, &quot;发热&quot;, 89, &quot;腹泻&quot;, 5, &quot;呕吐&quot;, 12, &quot;咳嗽&quot;, 102, &quot;咽痛&quot;, 98, &quot;乏力&quot;, 15, &quot;腹痛&quot;, 2, &quot;妄想&quot;, 3, &quot;幻听&quot;, 6, &quot;失眠&quot;, 1, &quot;贫血&quot;, 8, &quot;多动&quot;, 2, &quot;胸痛&quot;, 4, &quot;胸闷&quot;, 5 ) p1 &lt;- tb %&gt;% uncount(n) %&gt;% ggplot(aes(x = disease, fill = disease)) + geom_bar() + coord_flip() + theme(legend.position = &quot;none&quot;) p2 &lt;- tb %&gt;% uncount(n) %&gt;% mutate( disease = forcats::fct_lump(disease, 5), disease = forcats::fct_reorder(disease, .x = disease, .fun = length) ) %&gt;% ggplot(aes(x = disease, fill = disease)) + geom_bar() + coord_flip() + theme(legend.position = &quot;none&quot;) p1 + p2 14.17 unite df &lt;- tribble( ~school, ~class, &quot;chuansi&quot;, &quot;01&quot;, &quot;chuansi&quot;, &quot;02&quot;, &quot;shude&quot;, &quot;07&quot;, &quot;shude&quot;, &quot;08&quot;, &quot;huapulu&quot;, &quot;101&quot;, &quot;huapulu&quot;, &quot;103&quot; ) df df_united &lt;- df %&gt;% unite(school, class, col = &quot;school_plus_class&quot;, sep = &quot;_&quot;, remove = FALSE) df_united 当然，简单的情况也可以用mutate()实现 df %&gt;% mutate(newcol = str_c(school, &quot;_&quot;, class)) 14.18 separate() df_united %&gt;% separate(school_plus_class, into = c(&quot;sch&quot;, &quot;cls&quot;), sep = &quot;_&quot;, remove = F) 如果用mutate()来实现，语句就会比较复杂些 df_united %&gt;% mutate(sch = str_split(school_plus_class, &quot;_&quot;) %&gt;% map_chr(1)) %&gt;% mutate(cls = str_split(school_plus_class, &quot;_&quot;) %&gt;% map_chr(2)) 如果每行不是都恰好分隔成两部分呢？就需要tidyr::extract(), 使用方法和tidyr::separate()类似 df &lt;- tribble( ~school_class, &quot;chuansi_01&quot;, &quot;chuansi_02_03&quot;, &quot;shude_07_0&quot;, &quot;shude_08_0&quot;, &quot;huapulu_101_u&quot;, &quot;huapulu_103__p&quot; ) df df %&gt;% separate(school_class, into = c(&quot;sch&quot;, &quot;cls&quot;), sep = &quot;_&quot;, extra = &quot;drop&quot;, remove = F) 14.19 extract() 有时候分隔符搞不定的，可以用正则表达式，讲捕获的每组弄成一列 df &lt;- tibble(x = c(&quot;1-12week&quot;, &quot;1-10wk&quot;, &quot;5-12w&quot;, &quot;01-05weeks&quot;)) df df %&gt;% extract( x, c(&quot;start&quot;, &quot;end&quot;, &quot;letter&quot;), &quot;(\\\\d+)-(\\\\d+)([a-z]+)&quot;, remove = FALSE ) 14.20 crossing() 先看看效果 crossing(x = c(&quot;F&quot;, &quot;M&quot;), y = c(&quot;a&quot;, &quot;b&quot;), z = c(1:2)) 这个函数在数据模拟的时候很方便， crossing(trials = 1:10, m = 1:5) %&gt;% group_by(trials) %&gt;% mutate( guess = sample.int(5, n()), result = m == guess ) %&gt;% summarise(score = sum(result) / n()) 再来一个例子 sim &lt;- tribble( ~f, ~params, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 10) ) sim %&gt;% mutate(sim = invoke_map(f, params)) rep_sim &lt;- sim %&gt;% crossing(rep = 1:1e5) %&gt;% mutate(sim = invoke_map(f, params)) %&gt;% unnest(sim) %&gt;% group_by(rep) %&gt;% summarise(mean_sim = mean(sim)) head(rep_sim) rep_sim %&gt;% ggplot(aes(x = mean_sim)) + geom_histogram(binwidth = 0.05, fill = &quot;skyblue&quot;) + theme_classic() 也可用在较复杂的模拟，比如下面介绍的大数极限定理， sim &lt;- tribble( ~n_tosses, ~f, ~params, 10, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 15), 30, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 30), 100, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 100), 1000, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 1000), 10000, &quot;rbinom&quot;, list(size = 1, prob = 0.5, n = 1e4) ) sim_rep &lt;- sim %&gt;% crossing(replication = 1:50) %&gt;% mutate(sims = invoke_map(f, params)) %&gt;% unnest(sims) %&gt;% group_by(replication, n_tosses) %&gt;% summarise(avg = mean(sims)) sim_rep %&gt;% ggplot(aes(x = factor(n_tosses), y = avg)) + ggbeeswarm::geom_quasirandom(color = &quot;lightgrey&quot;) + scale_y_continuous(limits = c(0, 1)) + geom_hline( yintercept = 0.5, color = &quot;skyblue&quot;, lty = 1, size = 1, alpha = 3 / 4 ) + ggthemes::theme_pander() + labs( title = &quot;50 Replicates Of Mean &#39;Heads&#39; As Number Of Tosses Increase&quot;, y = &quot;mean&quot;, x = &quot;Number Of Tosses&quot; ) 数值模拟我们会在第 16 章专门介绍。 "],
["tibble.html", "第 15 章 简单数据框 15.1 tidyverse 家族 15.2 人性化的tibble 15.3 tibble 与 data.frame 15.4 tibble数据操作 15.5 关于行名 15.6 修复列名 15.7 nested tibble 15.8 延伸阅读", " 第 15 章 简单数据框 library(tidyverse) library(tibble) #事实上，library(tidyverse)已经加装了library(tibble) 15.1 tidyverse 家族 前面陆续介绍了tidyverse家族，家庭主要成员包括 功能 宏包 有颜值担当 ggplot2 数据处理王者 dplyr 数据转换专家 tidyr 数据载入利器 readr 循环加速器 purrr 强化数据框 tibble 15.2 人性化的tibble tibble是用来替换data.frame类型的扩展的数据框 tibble继承了data.frame，是弱类型的。换句话说，tibble是data.frame的子类型 tibble与data.frame有相同的语法，使用起来更方便 tibble更早的检查数据，方便写出更干净、更多富有表现力的代码 tibble对data.frame做了重新的设定： tibble，不关心输入类型，可存储任意类型，包括list类型 tibble，没有行名设置 row.names tibble，支持任意的列名 tibble，会自动添加列名 tibble，类型只能回收长度为1的输入 tibble，会懒加载参数，并按顺序运行 tibble，是tbl_df类型 15.3 tibble 与 data.frame 传统创建数据框 data.frame(a = 1:5, b = letters[1:5]) 发现，data.frame()会自动将字符串型的变量转换成因子型，如果想保持原来的字符串型，就得 data.frame(a = 1:5, b = letters[1:5], stringsAsFactors = FALSE) 用tibble创建数据框，不会这么麻烦，输出的就是原来的字符串类型 tibble(a = 1:5, b = letters[1:5]) 我们有时候喜欢这样，构建两个有关联的变量， 比如 tb &lt;- tibble( x = 1:3, y = x + 2 ) tb 但是，如果用传统的data.frame()来构建，会报错 df &lt;- data.frame( x = 1:3, y = x + 2 ) ## Error in x + 2: 二进列运算符中有非数值参数 df 因此，在这一点上tibble()做的比较人性化。 大家还可以发现tibble另一个优势：tibble输出时，会显示多一行，用来指定每一列的类型。 tibble用缩写定义了7种类型： 类型 含义 int 代表integer dbl 代表double chr 代表character向量或字符串 dttm 代表日期+时间(date+time) lgl 代表逻辑判断TRUE或者FALSE fctr 代表因子类型factor date 代表日期dates 15.4 tibble数据操作 15.4.1 创建tibble tibble()创建一个tibble类型的data.frame: tibble(a = 1:5, b = letters[1:5]) 刚才提到了，可以这样， tibble( a = 1:5, b = 10:14, c = a + b ) 为了让每列更加直观，也可以tribble()创建，数据量不大的时候，挺方便的 tribble( ~x, ~y, ~z, &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) 15.4.2 转换成tibble类型 转换成tibble类型意思就是说，刚开始不是tibble, 现在转换成tibble， 包括 data.frame转换成tibble vector转换成tibble list转换成tibble matrix转换成tibble 15.4.2.1 data.frame转换成tibble t1 &lt;- iris[1:6, 1:4] # data.frame类型: class(t1) ## [1] &quot;data.frame&quot; as_tibble(t1) 15.4.2.2 vector转型到tibble x &lt;- as_tibble(1:5) # Use `tibble::enframe() x 15.4.2.3 把list转型为tibble df &lt;- as_tibble(list(x = 1:6, y = runif(6), z = 6:1)) df 把tibble再转为list? as.list(df) 15.4.2.4 把matrix转型为tibble。 m &lt;- matrix(rnorm(15), ncol = 5) as_tibble(m) tibble转回matrix? as.matrix(df) 15.4.3 tibble简单操作 构建一个简单的数据框 df &lt;- tibble(x = 1:2, y = 2:1) df 增加一列 add_column(df, z = 0:1, w = 0) 增加一行 add_row(df, x = 99, y = 9) 在第二行，增加一行 add_row(df, x = 99, y = 9, .before = 2) 15.4.4 有用的函数lst lst，创建一个list，具有tibble特性的list。 lst(n = 5, x = runif(n), y = TRUE) ## $n ## [1] 5 ## ## $x ## [1] 0.2522 0.4062 0.6165 0.3442 0.5799 ## ## $y ## [1] TRUE 15.4.5 有用的函数enframe enframe()将矢量快速创建tibble，，创建的tibble只有2列: name和value enframe(1:3) enframe(c(a = 5, b = 7, c = 9)) 15.4.6 有用的函数deframe deframe()可以看做是enframe() 的反操作，把tibble反向转成向量 df &lt;- enframe(c(a = 5, b = 7)) df # 转为vector deframe(df) ## a b ## 5 7 15.4.7 读取文件 read_csv()读取文件时，生成的直接就是tibble read_csv(&quot;./demo_data/wages.csv&quot;) 15.5 关于行名 data.frame是支持行名的，但tibble不支持行名，这也是两者不同的地方 # 创建data.frame df &lt;- data.frame(x = 1:3, y = 3:1) # 给df增加行名 row.names(df) &lt;- LETTERS[1:3] df # 判断是否有行名 has_rownames(df) ## [1] TRUE 但是对于tibble tb &lt;- tibble(x = 1:3, y = 3:1) row.names(tb) &lt;- LETTERS[1:3] 需要注意的： 有时候遇到含有行名的data.frame，转换成tibble后，行名会被丢弃 如果想保留行名，就需要把行名转换成单独的一列 举个例子 df &lt;- mtcars[1:3, 1:3] df # 把行名转换为单独的一列 rownames_to_column(df, var = &quot;rowname&quot;) # 把行索引转换为单独的一列 rowid_to_column(df, var = &quot;rowid&quot;) 15.6 修复列名 规范的来说，数据框的列名应该是唯一。但现实中代码是人写的，因此可能会稀奇古怪的，所幸的是tibble也提供了人性化的解决方案 tibble(x = 1, x = 2) ## Error: Column name `x` must not be duplicated. ## Use .name_repair to specify repair. .name_repair = \"check_unique\" 检查列名唯一性，但不做修复（默认） .name_repair = \"minimal\"， 不检查也不修复，维持现状 .name_repair = \"unique\" 修复列名，使得列名唯一且不为空 .name_repair = \"universal\" 修复列名，使得列名唯一且语法可读 具体使用方法： tibble(x = 1, x = 2, .name_repair = &quot;minimal&quot;) tibble(x = 1, x = 2, .name_repair = &quot;unique&quot;) tibble(x = 1, x = 2, .name_repair = &quot;universal&quot;) tibble(`a 1` = 1, `a 2` = 2, .name_repair = &quot;universal&quot;) 如果认为x...1, x...2 不符合自己的审美，可以指定修复函数 tibble(x = 1, x = 2, .name_repair = make.unique) tibble(x = 1, x = 2, .name_repair = ~make.unique(.x, sep = &quot;_&quot;)) tibble(x = 1, x = 2, .name_repair = ~ make.names(., unique = TRUE)) 注意make.unique(names, sep = \".\")和make.names(names, unique = FALSE, allow_ = TRUE) 是基础包的函数，可通过?make.unique()或者make.names()获取说明文档。 当然也可以自定义函数 fix_names &lt;- function(x) gsub(&quot;\\\\s+&quot;, &quot;_&quot;, x) tibble(`year 1` = 1, `year 2` = 2, .name_repair = fix_names) 感觉越说越复杂了，事实上，我们写数据框的时候，完全可以避免上述问题，只要做到规范列名。 如果真正遇到比较乱的列名，推荐使用janitor::clean_names()一步到位。 library(janitor) tibble(`year 1` = 1, `year 2` = 2) %&gt;% clean_names() 15.7 nested tibble nested tibble 和 List-columns (列表列) 会在后面的章节详细介绍。 iris %&gt;% group_by(Species) %&gt;% nest() 15.8 延伸阅读 1、阅读Hadley Wickham的r4ds这本书第10章。 2、 tibble的官方主页：https://tibble.tidyverse.org/ 3、创建列表列的方法，可以参考nested tibble和 list-columns "],
["sampling.html", "第 16 章 模拟与抽样 16.1 模拟 16.2 MASS::mvrnorm 16.3 蒙特卡洛 16.4 抽样与样本 16.5 扩展阅读", " 第 16 章 模拟与抽样 library(tidyverse) 本章目的是在tidyverse的架构下，介绍一些模拟和抽样的知识。先回顾下Hadley Wickham提出的数据科学tidy原则，tidy思想体现在: 任何数据都可以规整为数据框 数据框的一列代表一个变量，数据框的一行代表一次观察 函数处理数据时，数据框进、数据框出 16.1 模拟 16.1.1 生成随机数 比如生成5个高斯分布的随机数，高斯分布就是正态分布，R语言里我们用rnorm()函数产生正态分布的随机数 rnorm(n = 5, mean = 0, sd = 1) ## [1] 0.7705 -0.1562 0.4386 -0.1980 0.6600 事实上，R内置了很多随机数产生的函数 Distrution Notation R Uniform \\(\\text{U}(a, b)\\) runif Normal \\(\\text{N}(\\mu, \\sigma)\\) rnorm Binormal \\(\\text{Bin}(n, p)\\) rbinorm Piosson \\(\\text{pois}(\\lambda)\\) rpois Beta \\(\\text{Beta}(\\alpha, \\beta)\\) rbeta 如果大家查看帮助文档?runif，会发现每种分布都有对应的四个函数 d:density p:cumulative probability q:quantile r:random dnorm(seq(0.1, 0.5, length.out = 10), mean = 0, sd = 1) ## [1] 0.3970 0.3948 0.3919 0.3882 0.3838 0.3788 0.3730 ## [8] 0.3666 0.3596 0.3521 在tidyverse的框架下，我们喜欢在数据框(data.frame)下运用这些函数，因为这样我们可以方便使用ggplot2来可视化， 例子1，我们生成100个正态分布的点，然后看看其分布 tibble( x = rnorm(n = 100, mean = 0, sd = 1) ) %&gt;% ggplot(aes(x = x)) + geom_density() 我们将模拟的正态分布和理论上正态分布画在一起 tibble( x = rnorm(n = 100, mean = 0, sd = 1) ) %&gt;% ggplot(aes(x = x)) + geom_density() + stat_function( fun = dnorm, args = list(mean = 0, sd = 1), color = &quot;red&quot; ) 如果我们模拟点再增加点，会越来越逼近理论上的分布。 例子2，在数据框(data.frame)下，建立模拟\\(x\\)和\\(y\\)的线性关系 \\[ y_i = 4 + 3.2\\, x_i\\] 现实中，观察值往往会带入误差，假定误差服从正态分布，那么\\(x\\)和\\(y\\)的线性关系重新表述为 \\[ y_i = \\beta_0 + \\beta_1\\, x_i + \\epsilon_i, \\quad \\epsilon \\in \\text{Normal}(\\mu =0, \\sigma =1) \\] beta_0 &lt;- 4 beta_1 &lt;- 3.2 epsilon &lt;- rnorm(n = 1000, mean = 0, sd = 1) sim_normal &lt;- tibble( # x_vals = runif(1000, 0, 10) x_vals = seq(from = 0, to = 5, length.out = 1000), y_vals = beta_0 + beta_1 * x_vals + epsilon, ) sim_normal %&gt;% head() sim_normal %&gt;% ggplot(aes(x = x_vals, y = y_vals)) + geom_point() 有时候为了方便，可以写简练点 tibble( a = runif(1000, 0, 5), b = 4 + rnorm(1000, mean = 3.2 * a, sd = 1) ) %&gt;% ggplot(aes(x = a, y = b)) + geom_point() 16.2 MASS::mvrnorm MASS::mvrnorm(n = 1, mu, Sigma)产生多元高斯分布的随机数，每组随机变量高度相关。 比如人的身高服从正态分布，人的体重也服从正态分布，同时身高和体重又存在强烈的关联。 n: 随机样本的大小 mu: 多元高斯分布的均值向量 Sigma: 协方差矩阵，主要这里是大写的S (Sigma)，提醒我们它是一个矩阵，不是一个数值 a &lt;- 3.5 b &lt;- -1 sigma_a &lt;- 1 sigma_b &lt;- 0.5 rho &lt;- -0.7 mu &lt;- c(a, b) cov_ab &lt;- sigma_a * sigma_b * rho # 协方差 # 构建协方差矩阵 sigma &lt;- matrix(c(sigma_a^2, cov_ab, cov_ab, sigma_b^2), ncol = 2) d &lt;- MASS::mvrnorm(1000, mu = mu, Sigma = sigma) %&gt;% data.frame() %&gt;% set_names(&quot;group_a&quot;, &quot;group_b&quot;) head(d) d %&gt;% ggplot(aes(x = group_a)) + geom_density(color = &quot;transparent&quot;, fill = &quot;dodgerblue3&quot;, alpha = 1/2) + stat_function(fun = dnorm, args = list(mean = 3.5, sd = 1), linetype = 2 ) d %&gt;% ggplot(aes(x = group_b)) + geom_density(color = &quot;transparent&quot;, fill = &quot;dodgerblue3&quot;, alpha = 1/2) + stat_function(fun = dnorm, args = list(mean = -1, sd = 0.5), linetype = 2 ) d %&gt;% ggplot(aes(x = group_a, y = group_b)) + geom_point() + stat_ellipse(type = &quot;norm&quot;, level = 0.95) 我们回头验算一下 d %&gt;% summarise( a_mean = mean(group_a), b_mean = mean(group_b), a_sd = sd(group_a), b_sd = sd(group_b), cor = cor(group_a,group_b), cov = cov(group_a,group_b) ) 16.3 蒙特卡洛 这是我研究生时候老师布置的一个的题目，当时我用的是C语言代码，现在我们有强大的tidyverse set.seed(2019) n &lt;- 50000 points &lt;- tibble(&quot;x&quot; = runif(n), &quot;y&quot; = runif(n)) points &lt;- points %&gt;% mutate(inside = map2_dbl(.x = x, .y = y, ~if_else(.x**2 + .y**2 &lt; 1, 1, 0))) %&gt;% rowid_to_column(&quot;N&quot;) 正方形的面积是1，圆的面积是\\(\\pi r^2 = \\frac{1}{4} \\pi\\)，如果知道两者的比例，就可以估算\\(\\pi\\) points &lt;- points %&gt;% mutate(estimate = 4*cumsum(inside)/N) points %&gt;% tail() points %&gt;% ggplot() + geom_line(aes(y = estimate, x = N), colour = &quot;#82518c&quot;) + geom_hline(yintercept = pi) 16.4 抽样与样本 16.4.1 总体分布 假定一个事实，川师男生总体的平均身高和身高的标准差分别为 true.mean &lt;- 175.7 true.sd &lt;- 15.19 那么我们可以模拟分布情况如下 pop.distn &lt;- tibble( height = seq(100, 250, 0.5), density = dnorm(height, mean = true.mean, sd = true.sd) ) ggplot(pop.distn) + geom_line(aes(height, density)) + geom_vline( xintercept = true.mean, color = &quot;red&quot;, linetype = &quot;dashed&quot; ) + geom_vline( xintercept = true.mean + true.sd, color = &quot;blue&quot;, linetype = &quot;dashed&quot; ) + geom_vline( xintercept = true.mean - true.sd, color = &quot;blue&quot;, linetype = &quot;dashed&quot; ) + labs( x = &quot;Height (cm)&quot;, y = &quot;Density&quot;, title = &quot;川师男生身高分布&quot; ) 16.4.2 样本 假定我们从中抽取30个男生身高样本 sample.a &lt;- tibble(height = rnorm(n = 30, mean = true.mean, sd = true.sd)) 然后看看样本的直方图 sample.a %&gt;% ggplot(aes(x = height)) + geom_histogram(aes(y = stat(density)), fill = &quot;steelblue&quot;, alpha = 0.75, bins = 10 ) + geom_line( data = pop.distn, aes(x = height, y = density), alpha = 0.25, size = 1.5 ) + geom_vline(xintercept = true.mean, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + geom_vline(xintercept = mean(sample.a$height), linetype = &quot;solid&quot;) 红色的虚线代表分布的总体的均值，黑色实线代表30个样本的均值， sample.a %&gt;% summarize( sample.mean = mean(height), sample.sd = sd(height) ) 也就是说，基于这30个观察值的样本，我们认为川师男生的身高均值为175.743cm，方差为17.3027 可能有同学说，这个样本太少了，计算的均值还不够科学，会以偏概全。于是又重新找了30个男生，和上次类似，用rnorm函数模拟，我们记为样本b sample.b &lt;- tibble(height = rnorm(30, mean = true.mean, sd = true.sd)) 再来看看这次样本的分布 sample.b %&gt;% ggplot(aes(x = height)) + geom_histogram(aes(y = stat(density)), fill = &quot;steelblue&quot;, alpha = 0.75, bins = 10 ) + geom_line( data = pop.distn, aes(x = height, y = density), alpha = 0.25, size = 1.5 ) + geom_vline(xintercept = true.mean, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + geom_vline(xintercept = mean(sample.a$height), linetype = &quot;solid&quot;) 同样，我们计算样本b的均值和方差 sample.b %&gt;% summarize( sample.mean = mean(height), sample.sd = sd(height) ) 这次抽样的结果，均值为173.711cm，方差为14.8641 和样本a比，有一点点变化。不经想问，我能否继续抽样呢？结果会有变化吗？为了避免重复写代码 ，我把上面的过程整合到一起，写一个子函数，专门模拟抽样过程 rnorm.stats &lt;- function(n, mu, sigma) { the.sample &lt;- rnorm(n, mu, sigma) tibble( sample.size = n, sample.mean = mean(the.sample), sample.sd = sd(the.sample) ) } 于是，我们又可以继续模拟了。注意我们之前设定的总体分布的均值和方差 true.mean &lt;- 175.7 true.sd &lt;- 15.19 rnorm.stats(30, true.mean, true.sd) yes，代码工作的很好，但不过只是代码减少了一点点，仍然只是一次抽样（这里30个样本为一次抽样），我们的目的是反复抽样， 抽很多次的那种喔。 那我们用purrr包的rerun函数偷个懒， df.samples.of.30 &lt;- purrr::rerun(2500, rnorm.stats(30, true.mean, true.sd)) %&gt;% dplyr::bind_rows() 哇，一下子抽了2500个样本,全部装进了df.sample.of.30这个数据框， 偷偷看一眼呢 df.samples.of.30 %&gt;% head() 回过头看看df.samples.of.30是什么： 从川师的男生中随机抽取30个，计算这30个人身高的均值和方差，这叫一次抽样 把上面的工作，重复2500次，得到2500个均值和方差 2500个均值和方差，组成了一个数据框 我们发现每次抽样的均值都不一样，感觉又像一个分布(抽样的均值分布)，我们画出来看看吧 df.samples.of.30 %&gt;% ggplot(aes(x = sample.mean, y = stat(density))) + geom_histogram(bins = 25, fill = &quot;firebrick&quot;, alpha = 0.5) + geom_vline(xintercept = true.mean, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + labs( title = &quot;抽样2500次（每次30个男生）身高均值的分布&quot;, subtitle = &quot;Distribution of mean heights for 2500 samples of size 30&quot; ) 注意到，这不是男生身高的分布，而是每次抽样计算的均值构成的分布. 为了更清楚的说明，我们把整体的分布(灰色曲线)、样本a（蓝色直方图）、抽样的均值分布（红色直方图）三者画在一起。 df.samples.of.30 %&gt;% ggplot(aes(x = sample.mean, y = stat(density))) + geom_histogram(bins = 50, fill = &quot;firebrick&quot;, alpha = 0.5) + geom_histogram( data = sample.a, aes(x = height, y = stat(density)), bins = 11, fill = &quot;steelblue&quot;, alpha = 0.25 ) + geom_vline(xintercept = true.mean, linetype = &quot;dashed&quot;, color = &quot;red&quot;) + geom_line(data = pop.distn, aes(x = height, y = density), alpha = 0.25, size = 1.5) + xlim(125, 225) 样本的均值分布，是个很有意思的结果，比如，我们再选30个男生再抽样一次，我们可以断定，这次抽样的均值会落在了红色的区间之内。 然而，注意到，必须限定再次抽样的大小仍然是30个男生，以上这句话才成立。 df.samples.of.30 %&gt;% summarize( mean.of.means = mean(sample.mean), sd.of.means = sd(sample.mean) ) 这里计算的是抽样(样本大小为30)均值分布，而不是整体的均值分布。言外之意，样本大小可以是其它的呗， 那就把样本调整为50、100、250、500分别试试看 df.samples.of.50 &lt;- rerun(2500, rnorm.stats(50, true.mean, true.sd)) %&gt;% bind_rows() df.samples.of.100 &lt;- rerun(2500, rnorm.stats(100, true.mean, true.sd)) %&gt;% bind_rows() df.samples.of.250 &lt;- rerun(2500, rnorm.stats(250, true.mean, true.sd)) %&gt;% bind_rows() df.samples.of.500 &lt;- rerun(2500, rnorm.stats(500, true.mean, true.sd)) %&gt;% bind_rows() 忍不住想画图看看，每次抽取的男生数量不同，均值的分布会有不同？ df.combined &lt;- bind_rows( df.samples.of.30, df.samples.of.50, df.samples.of.100, df.samples.of.250, df.samples.of.500 ) %&gt;% mutate(sample.sz = as.factor(sample.size)) df.combined %&gt;% ggplot(aes(x = sample.mean, y = stat(density), fill = sample.sz)) + geom_histogram(bins = 25, alpha = 0.5) + geom_vline(xintercept = true.mean, linetype = &quot;dashed&quot;) + facet_wrap(vars(sample.sz), nrow = 1) + scale_fill_brewer(palette = &quot;Set1&quot;) + labs( x = &quot;Sample means&quot;, y = &quot;Density&quot;, title = &quot;Distribution of mean heights for samples of varying size&quot; ) 随着样本大小由30增加到500，抽样的均值分布围绕着越来越聚合到实际的均值，或者说随着样本大小的增多，对均值估计的不确定性越小。 sampling.distn.mean.table &lt;- df.combined %&gt;% group_by(sample.size) %&gt;% summarize( mean.of.means = mean(sample.mean), sd.of.means = sd(sample.mean) ) sampling.distn.mean.table 有个统计学上的概念需要明确。 输出结果的第三列sd.of.means 是不同样本大小(30,50,100,250,500)下，反复抽样后平均数分布的标准差。 数学上，如果已知总体的标准差(\\(\\sigma\\))，那么抽取无限多份大小为 \\(n\\) 的样本，每个样本各有一个平均值，所有这个大小的样本之平均值的标准差可证明为 \\[ \\frac{\\sigma}{\\sqrt{n}} \\] 即，平均值的标准误差。 下面我们画图看看，模拟出来的\\(sd.of.means\\)和理论值\\(\\frac{\\sigma}{\\sqrt{n}}\\)是否一致。 注意到这里的\\(\\sigma\\)是总体的标准差，即最开始我们设定的川师男生身高的标准差true.sd. 也就说，理论上 df.se.mean.theory &lt;- tibble( sample.size = seq(10,500,10) ) %&gt;% mutate(std.error = true.sd/sqrt(sample.size)) df.se.mean.theory sampling.distn.mean.table %&gt;% ggplot(aes(x = sample.size, y = sd.of.means)) + geom_point() + geom_line(aes(x = sample.size, y = std.error), data = df.se.mean.theory, color = &quot;red&quot;) + labs( x = &quot;Sample size&quot;, y = &quot;Std Error of Mean&quot;, title = &quot;平均值标准误差随样本大小变化（理论值和模拟值对比）&quot; ) 两者吻合的很好。 刚刚我们看到的，抽样均值分布随着样本大小变化而变化。可以试想下，抽样的其他统计量分布（方差，中位数），是不是也随着样本大小变化而变化呢？ sampling.distn.sd.table &lt;- df.combined %&gt;% group_by(sample.size) %&gt;% summarize( mean.of.sds = mean(sample.sd), sd.of.sds = sd(sample.sd) ) sampling.distn.sd.table 答案是肯定的，样本量的增多，抽样方差的不确定性减少。 16.5 扩展阅读 https://learningstatisticswithr.com/book/ "],
["tidystats.html", "第 17 章 Tidy Statistics 17.1 从一个案例开始 17.2 单因素方差分析 17.3 双因素方差分析", " 第 17 章 Tidy Statistics 本章介绍基本的方差分析内容 library(tidyverse) 17.1 从一个案例开始 从这是一份1994年收集1379个对象关于收入、身高、教育水平等信息的数据集，数据在课件首页下载。 首先，我们下载后导入数据 wages &lt;- read_csv(&quot;./demo_data/wages.csv&quot;) wages %&gt;% head() %&gt;% knitr::kable() earn height sex race ed age 79571 73.89 male white 16 49 96397 66.23 female white 16 62 48711 63.77 female white 16 33 80478 63.22 female other 16 95 82089 63.08 female white 17 43 15313 64.53 female white 15 30 我们的问题：男性是否就比女性挣的多？ 17.2 单因素方差分析 t.test(earn ~ sex, data = wages) ## ## Welch Two Sample t-test ## ## data: earn by sex ## t = -12, df = 768, p-value &lt;2e-16 ## alternative hypothesis: true difference in means is not equal to 0 ## 95 percent confidence interval: ## -25324 -18171 ## sample estimates: ## mean in group female mean in group male ## 24246 45993 lm(earn ~ sex, data = wages) %&gt;% summary() ## ## Call: ## lm(formula = earn ~ sex, data = wages) ## ## Residuals: ## Min 1Q Median 3Q Max ## -46092 -20516 -4639 11722 271956 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 24246 1004 24.1 &lt;2e-16 *** ## sexmale 21748 1636 13.3 &lt;2e-16 *** ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 29400 on 1377 degrees of freedom ## Multiple R-squared: 0.114, Adjusted R-squared: 0.113 ## F-statistic: 177 on 1 and 1377 DF, p-value: &lt;2e-16 aov(earn ~ sex, data = wages) %&gt;% summary() ## Df Sum Sq Mean Sq F value Pr(&gt;F) ## sex 1 1.53e+11 1.53e+11 177 &lt;2e-16 *** ## Residuals 1377 1.19e+12 8.66e+08 ## --- ## Signif. codes: ## 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 17.3 双因素方差分析 我们采用ggpubr宏包下的ToothGrowth来说明，这个数据集包含60个样本，记录着每10只豚鼠在不同的喂食方法和不同的药物剂量下，牙齿的生长情况. len : 牙齿长度 supp : 两种喂食方法 (橙汁和维生素C) dose : 抗坏血酸剂量 (0.5, 1, and 2 mg) library(&quot;ggpubr&quot;) my_data &lt;- ToothGrowth %&gt;% mutate_at(vars(supp, dose), ~ as_factor(.)) my_data %&gt;% head() my_data %&gt;% ggplot(aes(x = supp, y = len, fill = supp)) + geom_boxplot(position = position_dodge()) + facet_wrap(vars(dose)) + labs(title = &quot;VC剂量和摄入方式对豚鼠牙齿的影响&quot;) 问题：豚鼠牙齿的长度是否与药物的食用方法和剂量有关？ 线性回归时，我们是通过独立变量来预测响应变量，但现在我们关注的重点会从预测转向不同组别差异之间的分析，这即为方差分析（ANOVA）。 这里是两个解释变量，所以问题需要双因素方差分析 (ANOVA) aov(len ~ supp + dose, data = my_data) %&gt;% broom::tidy() 检验表明不同类型之间存在显著差异，但是并没有告诉我们具体谁与谁之间的不同。需要多重比较帮助我们解决这个问题。使用TurkeyHSD函数 aov(len ~ supp + dose, data = my_data) %&gt;% TukeyHSD(which = &quot;dose&quot;) %&gt;% broom::tidy() aov(len ~ supp + dose, data = my_data) %&gt;% TukeyHSD(which = &quot;supp&quot;) %&gt;% broom::tidy() 思考：交互效应是否显著？ aov(len ~ supp * dose, data = my_data) %&gt;% broom::tidy() "],
["lm.html", "第 18 章 线性回归 18.1 从一个案例开始 18.2 线性回归模型 18.3 使用lm() 函数 18.4 模型的解释 18.5 多元线性回归 18.6 更多模型 18.7 可能遇到的情形 18.8 延伸阅读", " 第 18 章 线性回归 线性模型是数据分析中最常用的一种分析方法。最基础的往往最深刻。 library(tidyverse) 18.1 从一个案例开始 这是一份1994年收集1379个对象关于收入、身高、教育水平等信息的数据集。数据在课件首页提供了下载链接。 首先，我们下载后导入数据 wages &lt;- read_csv(&quot;./demo_data/wages.csv&quot;) wages %&gt;% head() 18.1.1 缺失值检查 一般情况下，拿到一份数据，首先要了解数据，知道每个变量的含义， wages %&gt;% colnames() ## [1] &quot;earn&quot; &quot;height&quot; &quot;sex&quot; &quot;race&quot; &quot;ed&quot; ## [6] &quot;age&quot; 同时检查数据是否有缺失值，这点很重要。在R中 NA（notavailable，不可用）表示缺失值, 比如可以这样检查是否有缺失值。 # 如何检查数据是否有缺失值？ wages %&gt;% summarise( earn_na = sum(is.na(earn)), height_na = sum(is.na(height)), sex_na = sum(is.na(sex)), race_na = sum(is.na(race)), ed_na = sum(is.na(ed)), age_na = sum(is.na(age)) ) 程序员都是偷懒的，所以也可以写的简便一点。大家在学习的过程中，也会慢慢的发现tidyverse的函数很贴心，很周到。 wages %&gt;% summarise_all( ~ sum(is.na(.)) ) 当然，也可以用purrr::map()的方法。这部分我会在后面的章节中逐步介绍。 wages %&gt;% map_df(~ sum(is.na(.))) 18.1.2 变量简单统计 然后探索下每个变量的分布。比如调研数据中男女的数量分别是多少？ wages %&gt;% count(sex) 男女这两组的身高均值分别是多少？收入的均值分别是多少？ wages %&gt;% group_by(sex) %&gt;% summarise( n = n(), mean_height = mean(height), mean_earn = mean(earn) ) 也有可以用可视化的方法，呈现男女收入的分布情况 wages %&gt;% ggplot(aes(x = earn, color = sex)) + geom_density() 大家可以自行探索其他变量的情况。现在提出几个问题，希望大家带着这些问题去探索： 长的越高的人挣钱越多？ 是否男性就比女性挣的多？ 影响收入最大的变量是哪个？ 怎么判定我们建立的模型是不是很好？ 18.2 线性回归模型 长的越高的人挣钱越多？ 要回答这个问题，我们先介绍线性模型。顾名思义，就是认为\\(x\\)和\\(y\\)之间有线性关系，数学上可以写为 \\[ \\begin{aligned} y &amp;= \\alpha + \\beta x + \\epsilon \\\\ \\epsilon &amp;\\in \\text{Normal}(\\mu, \\sigma) \\end{aligned} \\] $ $ 代表误差项，它与\\(x\\) 无关，且服从正态分布。 建立线性模型，就是要估计这里的系数\\(\\hat\\alpha\\)和\\(\\hat\\beta\\)，即截距项和斜率项。常用的方法是最小二乘法（ordinary least squares (OLS) regression）： 就是我们估算的\\(\\hat\\alpha\\)和\\(\\hat\\beta\\), 要使得残差的平方和最小，即\\(\\sum_i(y_i - \\hat y_i)^2\\)或者叫\\(\\sum_i \\epsilon_i^2\\)最小。当然，数据量很大，手算是不现实的，我们借助R语言代码吧 18.3 使用lm() 函数 用R语言代码(建议大家先?lm看看帮助文档)， lm参数很多, 但很多我们都用不上，所以我们只关注其中重要的两个参数 lm(formula = y ~ x, data) lm(y ~ x, data) 是最常用的线性模型函数(lm是linear model的缩写)。参数解释说明 formula：指定回归模型的公式，对于简单的线性回归模型y ~ x. ~ 符号：代表“预测”，可以读做“y由x预测”。有些学科不同的表述，比如下面都是可以的 response ~ explanatory dependent ~ independent outcome ~ predictors data：代表数据框，数据框包含了响应变量和独立变量 在运行lm()之前，先画出身高和收入的散点图(记在我们想干什么，寻找身高和收入的关系) wages %&gt;% ggplot(aes(x = height, y = earn)) + geom_point() 等不及了，就运行代码吧 mod1 &lt;- lm(formula = earn ~ height, data = wages) 这里我们将earn作为响应变量，height为预测变量。lm()返回赋值给mod1. mod1现在是个什么东东呢？ mod1是一个叫lm object或者叫类的东西， names(mod1) ## [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; ## [4] &quot;rank&quot; &quot;fitted.values&quot; &quot;assign&quot; ## [7] &quot;qr&quot; &quot;df.residual&quot; &quot;xlevels&quot; ## [10] &quot;call&quot; &quot;terms&quot; &quot;model&quot; 我们打印看看，会发生什么 print(mod1) ## ## Call: ## lm(formula = earn ~ height, data = wages) ## ## Coefficients: ## (Intercept) height ## -126523 2387 这里有两部分信息。首先第一部分是我们建立的模型；第二部分是R给出了截距（\\(\\alpha = -126532\\)）和斜率（\\(\\beta = 2387\\)）. 也就是说我们建立的线性回归模型是 \\[ \\hat y = -126532 + 2387 \\; x \\] 18.4 模型的解释 建立一个lm模型是简单的，然而最重要的是，我们能解释这个模型。 mod1的解释： 对于斜率\\(\\beta = 2387\\)意味着，当一个人的身高是68英寸时，他的预期收入\\(earn = -126532 + 2387 \\times 68= 35806\\) 美元， 换个方式说，身高\\(height\\)每增加一个1英寸, 收入\\(earn\\)会增加2387美元。 对于截距\\(\\alpha = -126532\\)，即当身高为0时，期望的收入值-126532。呵呵，人的身高不可能为0，所以这是一种极端的理论情况，现实不可能发生。 wages %&gt;% ggplot(aes(x = height, y = earn)) + geom_point(alpha = 0.25) + geom_smooth(method = &quot;lm&quot;, se = FALSE) 18.5 多元线性回归 刚才讨论的单个预测变量height，现在我们增加一个预测变量ed，稍微扩展一下我们的一元线性模型，就是多元回归模型 \\[ \\begin{aligned} earn &amp;= \\alpha + \\beta_1 \\text{height} + \\beta_2 \\text{ed} +\\epsilon \\\\ \\end{aligned} \\] R语言代码实现也很简单，只需要把变量ed增加在公式的右边 mod2 &lt;- lm(earn ~ height + ed, data = wages) 同样，我们打印mod2看看 mod2 ## ## Call: ## lm(formula = earn ~ height + ed, data = wages) ## ## Coefficients: ## (Intercept) height ed ## -161541 2087 4118 大家试着解释下mod2. 😄 18.6 更多模型 lm(earn ~ sex, data = wages) lm(earn ~ ed, data = wages) lm(earn ~ age, data = wages) lm(earn ~ height + sex, data = wages) lm(earn ~ height + ed, data = wages) lm(earn ~ height + age, data = wages) lm(earn ~ height + race, data = wages) lm(earn ~ height + sex + ed, data = wages) lm(earn ~ height + sex + age, data = wages) lm(earn ~ height + sex + race, data = wages) lm(earn ~ height + ed + age, data = wages) lm(earn ~ height + ed + race, data = wages) lm(earn ~ height + age + race, data = wages) lm(earn ~ height + sex + ed + age, data = wages) lm(earn ~ height + sex + ed + race, data = wages) lm(earn ~ height + sex + age + race, data = wages) lm(earn ~ height + ed + age + race, data = wages) lm(earn ~ sex + ed + age + race, data = wages) lm(earn ~ height + sex + ed + age + race, data = wages) 18.7 可能遇到的情形 根据同学们的建议，模型中涉及统计知识，留给统计老师讲，我们这里是R语言课，应该讲代码。 因此，这里再介绍几种线性回归中遇到的几种特殊情况 18.7.1 截距项 # 包含截距，以下两者是等价的 lm(earn ~ 1 + height, data = wages) lm(earn ~ height, data = wages) # 去掉截距，以下两者是等价的 lm(earn ~ height - 1, data = wages) lm(earn ~ 0 + height, data = wages) 18.7.2 只有截距 lm(earn ~ 1, data = wages) ## ## Call: ## lm(formula = earn ~ 1, data = wages) ## ## Coefficients: ## (Intercept) ## 32446 wages %&gt;% summarise( mean_wages = mean(earn) ) 18.7.3 分类变量 race变量就是数据框wages的一个分类变量，代表四个不同的种族。用分类变量做回归，本质上是各组之间的进行比较。 wages %&gt;% distinct(race) wages %&gt;% ggplot(aes(x = race, y = earn, fill = race)) + geom_boxplot(position = position_dodge()) + scale_y_continuous(limits = c(0, 20000)) 以分类变量作为解释变量，做线性回归 mod3 &lt;- lm(earn ~ race, data = wages) mod3 ## ## Call: ## lm(formula = earn ~ race, data = wages) ## ## Coefficients: ## (Intercept) racehispanic raceother ## 28372 -2887 3905 ## racewhite ## 4993 tidyverse框架下，喜欢数据框的统计结果，因此，可用broom的tidy()函数将模型输出转换为数据框的形式 broom::tidy(mod3) 我们看到输出结果，只有race_hispanic、 race_other和race_white三个系数和Intercept截距，race_black去哪里了呢？ 事实上，race变量里有4组，回归时，选择black为基线，hispanic的系数，可以理解为由black切换到hispanic，引起earn收入的变化（效应） 对 black 组的估计，earn = 28372.09 = 28372.09 对 hispanic组的估计，earn = 28372.09 + -2886.79 = 25485.30 对 other 组的估计，earn = 28372.09 + 3905.32 = 32277.41 对 white 组的估计，earn = 28372.09 + 4993.33 = 33365.42 分类变量的线性回归本质上就是方差分析 第 17 章专题讨论方差分析 18.7.4 因子变量 hispanic组的估计最低，适合做基线，因此可以将race转换为因子变量，这样方便调整因子先后顺序 wages_fct &lt;- wages %&gt;% mutate(race = factor(race, levels = c(&quot;hispanic&quot;, &quot;white&quot;, &quot;black&quot;, &quot;other&quot;))) %&gt;% select(earn, race) head(wages_fct) wages_fct替换wages，然后建立线性模型 mod4 &lt;- lm(earn ~ race, data = wages_fct) broom::tidy(mod4) 以hispanic组作为基线，各组系数也调整了，但加上截距后，实际值是没有变的。 大家可以用sex变量试试看 lm(earn ~ sex, data = wages) 18.7.5 一个分类变量和一个连续变量 如果预测变量是一个分类变量和一个连续变量 mod5 &lt;- lm(earn ~ height + sex, data = wages) coef(mod5) ## (Intercept) height sexmale ## -32479.9 879.4 16874.2 height = 879.424 当sex保持不变时，height变化引起的earn变化 sexmale = 16874.158 当height保持不变时，sex变化(female变为male)引起的earn变化 wages %&gt;% ggplot(aes(x = height, y = earn, color = sex)) + geom_point(alpha = 0.1) + geom_line(aes(y = predict(mod5))) + scale_y_continuous(limits = c(0, 100000)) 18.7.6 偷懒的写法 . is shorthand for “everything else.” lm(earn ~ height + sex + race + ed + age, data = wages) lm(earn ~ ., data = wages) lm(earn ~ height + sex + race + ed, data = wages) lm(earn ~ . - age, data = wages) R 语言很多时候都出现了.，不同的场景，含义是不一样的。我会在后面第 23 章专门讨论这个问题， 这是一个非常重要的问题 18.7.7 交互项 lm(earn ~ height + sex + height:sex, data = wages) lm(earn ~ height * sex, data = wages) lm(earn ~ (height + sex)^2, data = wages) lm(earn ~ height:sex, data = wages) lm(earn ~ height:sex:race, data = wages) mod6 &lt;- lm(earn ~ height + sex + height:sex, data = wages) coef(mod6) ## (Intercept) height sexmale ## -12167.0 564.5 -30510.4 ## height:sexmale ## 701.4 对于女性，height增长1个单位，引起earn的增长564.5102 对于男性，height增长1个单位，引起earn的增长564.5102 + 701.4065 = 1265.92 wages %&gt;% ggplot(aes(x = height, y = earn, color = sex)) + geom_point(alpha = 0.1) + geom_line(aes(y = predict(mod6))) + scale_y_continuous(limits = c(0, 100000)) 18.7.8 predict vs fit fitted() , 模型一旦建立，可以使用拟合函数fitted()返回拟合值，建模和拟合使用的是同一数据 predict()， 模型建立后，可以用新的数据进行预测，predict()要求数据框包含新的预测变量，如果没有提供，那么就使用建模时的预测变量进行预测，这种情况下，得出的结果和fitted()就时一回事了。 predict()函数和fitted()函数不同的地方，还在于predict()函数往往带有返回何种类型的选项，可以是具体数值，也可以是分类变量。具体会在第 19 章介绍。 18.7.9 回归和相关的关系 相关，比如求两个变量的相关系数cor(x, y) 回归，也是探寻自变量和因变量的关系，一般用来预测 回归分析中，如果自变量只有一个\\(x\\)，也就是模型lm(y~x)，那么回归和相关就有关联了。 比如：计算身高和收入两者的Pearson相关系数的平方 r &lt;- cor(wages$height, wages$earn) print( r^2 ) ## [1] 0.08503 然后看看，身高和收入的线性模型 lm(formula = earn ~ height, data = wages) %&gt;% broom::glance() %&gt;% pull(r.squared) ## [1] 0.08503 相关系数的平方 和 线性模型的\\(R^2\\)是相等的 18.8 延伸阅读 一篇极富思考性和启发性的文章《常见统计检验的本质是线性模型》 "],
["tidymodels.html", "第 19 章 机器学习", " 第 19 章 机器学习 library(tidyverse) library(tidymodels) "],
["tidyeval.html", "第 20 章 非标准性评估", " 第 20 章 非标准性评估 library(tidyverse) "],
["advR.html", "第 21 章 tidyverse进阶 21.1 scoped 函数 21.2 summarise_if 21.3 filter_if() 21.4 group_by 21.5 列名清理 21.6 缺失值检查与处理 21.7 标准化 21.8 arcoss函数", " 第 21 章 tidyverse进阶 让我们继续聊聊，相见恨晚的tidyverse library(tidyverse) 21.1 scoped 函数 在第 6 章介绍了dplyr的一些函数（mutate(), select()等等），事实上，这些函数加上后缀 _all, _at, _if，形成三组变体函数，可以方便对特定的子集进行操作。比如 对数据框所有列操作，可以用_all 对数据框指定的几列操作，可以用_at 对数据框符合条件的几列进行操作，可以用_if Operate _all _at _if select() select_all() select_at() select_if() mutate() mutate_all() mutate_at() mutate_if() rename() rename_all() rename_at() rename_if() arrange() arrange_all() arrange_at() arrange_if() filter() filter_all() filter_at() filter_if() distinct() distinct_all() distinct_at() distinct_if() group_by() group_by_all() group_by_at() group_by_if() summarise() summarise_all() summarise_at() summarise_if() map() map_all() map_at() map_if() modify() modify_all() modify_at() modify_if() 下面选取其中几个函数加以说明 21.1.1 mutate_if df_iris &lt;- iris %&gt;% head(5) df_iris df_iris %&gt;% mutate_if(is.double, as.integer) 可以一次性增加多列 df_iris %&gt;% mutate_if(is.numeric, list(scale, log)) 也可以把函数放在list()中，用 Purrr-style lambda 形式写出 df_iris %&gt;% mutate_if(is.numeric, list(~ scale(.), ~ log(.))) 21.1.2 select_if() df &lt;- tibble::tibble( x = letters[1:3], y = c(1:3), z = c(0, 0, 0) ) df df %&gt;% select_if(is.numeric) df %&gt;% select_if(~ n_distinct(.) &gt; 2) select_if 多个条件的情况 df %&gt;% select_if( list(~ (is.numeric(.) | is.character(.))) ) df %&gt;% select_if( ~ (is.numeric(.) | is.character(.)) ) to_keep &lt;- function(x) is.numeric(x) | is.character(x) df %&gt;% select_if(to_keep) df %&gt;% select_if( list(~ (is.numeric(.) &amp;&amp; sum(.) &gt; 2)) ) df %&gt;% select_if( list(~ (is.numeric(.) &amp;&amp; mean(.) &gt; 1)) ) 我们也可以写成函数的形式 to_want &lt;- function(x) is.numeric(x) &amp;&amp; sum(x) &gt; 3 df %&gt;% select_if(to_want) 21.2 summarise_if msleep &lt;- ggplot2::msleep msleep %&gt;% group_by(vore) %&gt;% summarise_all(~ mean(., na.rm = TRUE)) msleep &lt;- ggplot2::msleep msleep %&gt;% group_by(vore) %&gt;% # summarise_if(is.numeric, ~mean(., na.rm = TRUE)) summarise_if(is.numeric, mean, na.rm = TRUE) 21.3 filter_if() 事实上，filter已经很强大了，有了scoped函数，就如虎添翼了 msleep &lt;- ggplot2::msleep msleep %&gt;% select(name, sleep_total) %&gt;% filter(sleep_total &gt; 18) msleep %&gt;% select(name, sleep_total) %&gt;% filter(between(sleep_total, 16, 18)) msleep %&gt;% select(name, sleep_total) %&gt;% # filter(near(sleep_total, 17, tol=sd(sleep_total))) filter(near(sleep_total, mean(sleep_total), tol = 0.5 * sd(sleep_total))) mtcars是 R内置数据集，记录了32种不同品牌的轿车的的11个属性 mtcars filter_if()配合all_vars(), any_vars()函数，可以完成很酷的工作. 比如，要求一行中所有变量的值都大于150 mtcars %&gt;% filter_all(all_vars(. &gt; 150)) 比如，要求一行中至少有一个变量的值都大于150 # Or the union: mtcars %&gt;% filter_all(any_vars(. &gt; 150)) # You can vary the selection of columns on which to apply the predicate. # filter_at() takes a vars() specification: mtcars %&gt;% filter_at(vars(starts_with(&quot;d&quot;)), any_vars((. %% 2) == 0)) filter_if(.tbl, .predicate, .vars_predicate) 相对复杂点，我这里多说几句。 filter_if() 有三个参数： .tbl, 数据框 .predicate, 应用在列上的函数，一般作为列的选择条件 .vars_predicate, 应用在一行上的函数，通过 all_vars(), any_vars()返回值决定是否选取该行。 # And filter_if() selects variables with a predicate function: # filter_if(.tbl, .predicate, .vars_predicate) # mtcars %&gt;% map_df(~ all(floor(.) == .) ) # mtcars %&gt;% select_if( ~ all(floor(.) == .) ) mtcars %&gt;% filter_if(~ all(floor(.) == .), all_vars(. != 0)) 所以这里是，先通过.predicate = ~ all(floor(.) == .) 选取变量值为整数的列，然后再看选取的这些列的行方向，如果每一行的值.vars_predicate = all_vars(. != 0) ，都不为0，就保留下来，否则过滤掉。 简单点说，这段代码的意思，数值全部为整数的列，不能同时为0 21.4 group_by group_by() 用的很多，所以要多讲讲 mtcars %&gt;% group_by(cyl) mtcars %&gt;% group_by_at(vars(cyl)) # Group a data frame by all variables: mtcars %&gt;% group_by_all() # Group by variables selected with a predicate: iris %&gt;% group_by_if(is.factor) 21.4.1 group_split(), group_map(), group_modify() iris %&gt;% group_by(Species) %&gt;% group_split() ## [[1]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[2]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 3.2 4.7 1.4 ## 2 6.4 3.2 4.5 1.5 ## 3 6.9 3.1 4.9 1.5 ## 4 5.5 2.3 4 1.3 ## 5 6.5 2.8 4.6 1.5 ## 6 5.7 2.8 4.5 1.3 ## 7 6.3 3.3 4.7 1.6 ## 8 4.9 2.4 3.3 1 ## 9 6.6 2.9 4.6 1.3 ## 10 5.2 2.7 3.9 1.4 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[3]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6.3 3.3 6 2.5 ## 2 5.8 2.7 5.1 1.9 ## 3 7.1 3 5.9 2.1 ## 4 6.3 2.9 5.6 1.8 ## 5 6.5 3 5.8 2.2 ## 6 7.6 3 6.6 2.1 ## 7 4.9 2.5 4.5 1.7 ## 8 7.3 2.9 6.3 1.8 ## 9 6.7 2.5 5.8 1.8 ## 10 7.2 3.6 6.1 2.5 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## attr(,&quot;ptype&quot;) ## # A tibble: 0 x 5 ## # ... with 5 variables: Sepal.Length &lt;dbl&gt;, ## # Sepal.Width &lt;dbl&gt;, Petal.Length &lt;dbl&gt;, ## # Petal.Width &lt;dbl&gt;, Species &lt;fct&gt; 简单点写，就是 iris %&gt;% group_split(Species) ## [[1]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[2]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 3.2 4.7 1.4 ## 2 6.4 3.2 4.5 1.5 ## 3 6.9 3.1 4.9 1.5 ## 4 5.5 2.3 4 1.3 ## 5 6.5 2.8 4.6 1.5 ## 6 5.7 2.8 4.5 1.3 ## 7 6.3 3.3 4.7 1.6 ## 8 4.9 2.4 3.3 1 ## 9 6.6 2.9 4.6 1.3 ## 10 5.2 2.7 3.9 1.4 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[3]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6.3 3.3 6 2.5 ## 2 5.8 2.7 5.1 1.9 ## 3 7.1 3 5.9 2.1 ## 4 6.3 2.9 5.6 1.8 ## 5 6.5 3 5.8 2.2 ## 6 7.6 3 6.6 2.1 ## 7 4.9 2.5 4.5 1.7 ## 8 7.3 2.9 6.3 1.8 ## 9 6.7 2.5 5.8 1.8 ## 10 7.2 3.6 6.1 2.5 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## attr(,&quot;ptype&quot;) ## # A tibble: 0 x 5 ## # ... with 5 variables: Sepal.Length &lt;dbl&gt;, ## # Sepal.Width &lt;dbl&gt;, Petal.Length &lt;dbl&gt;, ## # Petal.Width &lt;dbl&gt;, Species &lt;fct&gt; 如果使用group_split(), 注意分组后，返回的是列表 iris %&gt;% group_split(Species) ## [[1]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 ## 7 4.6 3.4 1.4 0.3 ## 8 5 3.4 1.5 0.2 ## 9 4.4 2.9 1.4 0.2 ## 10 4.9 3.1 1.5 0.1 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[2]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 3.2 4.7 1.4 ## 2 6.4 3.2 4.5 1.5 ## 3 6.9 3.1 4.9 1.5 ## 4 5.5 2.3 4 1.3 ## 5 6.5 2.8 4.6 1.5 ## 6 5.7 2.8 4.5 1.3 ## 7 6.3 3.3 4.7 1.6 ## 8 4.9 2.4 3.3 1 ## 9 6.6 2.9 4.6 1.3 ## 10 5.2 2.7 3.9 1.4 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## [[3]] ## # A tibble: 50 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 6.3 3.3 6 2.5 ## 2 5.8 2.7 5.1 1.9 ## 3 7.1 3 5.9 2.1 ## 4 6.3 2.9 5.6 1.8 ## 5 6.5 3 5.8 2.2 ## 6 7.6 3 6.6 2.1 ## 7 4.9 2.5 4.5 1.7 ## 8 7.3 2.9 6.3 1.8 ## 9 6.7 2.5 5.8 1.8 ## 10 7.2 3.6 6.1 2.5 ## # ... with 40 more rows, and 1 more variable: ## # Species &lt;fct&gt; ## ## attr(,&quot;ptype&quot;) ## # A tibble: 0 x 5 ## # ... with 5 variables: Sepal.Length &lt;dbl&gt;, ## # Sepal.Width &lt;dbl&gt;, Petal.Length &lt;dbl&gt;, ## # Petal.Width &lt;dbl&gt;, Species &lt;fct&gt; 既然是列表，当然想到用前面讲到的purrr::map()家族 iris %&gt;% group_split(Species) %&gt;% purrr::map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) ## [[1]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.803 0.344 2.34 0.0238 ## 2 Sepal.Length 0.132 0.0685 1.92 0.0607 ## ## [[2]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.185 0.514 0.360 7.20e- 1 ## 2 Sepal.Length 0.686 0.0863 7.95 2.59e-10 ## ## [[3]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.610 0.417 1.46 1.50e- 1 ## 2 Sepal.Length 0.750 0.0630 11.9 6.30e-16 iris %&gt;% group_split(Species) %&gt;% map_df(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) 上面这个代码，数据框分割成list, 处理完后再合并成数据框，难道不觉得折腾么？ 为什么直接点？ tidyverse不会让我们失望的，先看看group_map() ## The result of .f should be a data frame(.f 必须返回数据框) ## `group_map()` return a list of tibble(返回元素均为df的一个列表list(df1,df2,df3)) iris %&gt;% group_by(Species) %&gt;% group_map(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) ## [[1]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.803 0.344 2.34 0.0238 ## 2 Sepal.Length 0.132 0.0685 1.92 0.0607 ## ## [[2]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.185 0.514 0.360 7.20e- 1 ## 2 Sepal.Length 0.686 0.0863 7.95 2.59e-10 ## ## [[3]] ## # A tibble: 2 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 0.610 0.417 1.46 1.50e- 1 ## 2 Sepal.Length 0.750 0.0630 11.9 6.30e-16 数据框进来，然后分组，依次处理成一个个数据框，最后以列表形式（a list of tibble）输出。 事实上，group_map()是返回list形式，也就是说，可以是返回任何形式，（a list of tibble）是其中特殊形式。 可以看看下面这个 iris %&gt;% group_by(Species) %&gt;% group_map( ~ lm(Petal.Length ~ Sepal.Length, data = .x) ) ## [[1]] ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length, data = .x) ## ## Coefficients: ## (Intercept) Sepal.Length ## 0.803 0.132 ## ## ## [[2]] ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length, data = .x) ## ## Coefficients: ## (Intercept) Sepal.Length ## 0.185 0.686 ## ## ## [[3]] ## ## Call: ## lm(formula = Petal.Length ~ Sepal.Length, data = .x) ## ## Coefficients: ## (Intercept) Sepal.Length ## 0.61 0.75 group_modify() 才是真正意义上的“数据框进、数据框出”。 iris %&gt;% group_by(Species) %&gt;% group_modify(~ broom::tidy(lm(Petal.Length ~ Sepal.Length, data = .x))) 为了大家方便查阅和记忆，我总结下表 函数 说明 常用组合 返回值 要求 map() 列表进、列表出 df %&gt;% group_split() %&gt;% map() list map_df() 列表进、数据框出 df %&gt;% group_split() %&gt;% map_df() df group_map() 数据框进、列表出 df %&gt;% group_by() %&gt;% group_map() 返回list(list1, list2, …) 特例list(df1, df2, …) group_modify() 数据框进、数据框出 df %&gt;% group_by() %&gt;% group_modify() 返回grouped tibble .f返回df walk 列表进 df %&gt;% group_split() %&gt;%walk() side effects group_walk() 数据框进 df %&gt;% group_by() %&gt;% group_walk() side effects 我常用的批量出图的语句 nobel_winners %&gt;% group_split(category) %&gt;% purrr::map( ~ ggplot(data = .x, aes(x = prize_age)) + geom_density() + ggtitle(.x$category) ) nobel_winners %&gt;% group_by(category) %&gt;% group_map( ~ ggplot(data = .x, aes(x = prize_age)) + geom_density() + ggtitle(.y) ) nobel_winners %&gt;% group_by(category) %&gt;% group_walk( ~ ggsave( paste0(.y, &#39;.png&#39;), ggplot(data = .x, aes(x = prize_age) ) + geom_density() + ggtitle(.y), device = &#39;png&#39;, path = temp ) ) %&gt;% invisible() 21.4.2 其他group函数 group_nest(), group_data(), group_keys(), group_rows() 21.5 列名清理 数据框的列名，不要用有空格和中文。 如果拿到的原始数据中列比较多，手动修改麻烦，可以使用janitor::clean_names()函数 library(readxl) library(janitor) # install.packages(&quot;janitor&quot;) roster_raw &lt;- read_excel(here::here(&quot;demo_data&quot;, &quot;dirty_data.xlsx&quot;)) glimpse(roster_raw) ## Observations: 13 ## Variables: 11 ## $ `First Name` &lt;chr&gt; &quot;Jason&quot;, &quot;Jason&quot;, &quot;Ali... ## $ `Last Name` &lt;chr&gt; &quot;Bourne&quot;, &quot;Bourne&quot;, &quot;K... ## $ `Employee Status` &lt;chr&gt; &quot;Teacher&quot;, &quot;Teacher&quot;, ... ## $ Subject &lt;chr&gt; &quot;PE&quot;, &quot;Drafting&quot;, &quot;Mus... ## $ `Hire Date` &lt;dbl&gt; 39690, 39690, 37118, 2... ## $ `% Allocated` &lt;dbl&gt; 0.75, 0.25, 1.00, 1.00... ## $ `Full time?` &lt;chr&gt; &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;... ## $ `do not edit! ---&gt;` &lt;lgl&gt; NA, NA, NA, NA, NA, NA... ## $ Certification...9 &lt;chr&gt; &quot;Physical ed&quot;, &quot;Physic... ## $ Certification...10 &lt;chr&gt; &quot;Theater&quot;, &quot;Theater&quot;, ... ## $ Certification...11 &lt;lgl&gt; NA, NA, NA, NA, NA, NA... roster &lt;- roster_raw %&gt;% clean_names() glimpse(roster) ## Observations: 13 ## Variables: 11 ## $ first_name &lt;chr&gt; &quot;Jason&quot;, &quot;Jason&quot;, &quot;Alici... ## $ last_name &lt;chr&gt; &quot;Bourne&quot;, &quot;Bourne&quot;, &quot;Key... ## $ employee_status &lt;chr&gt; &quot;Teacher&quot;, &quot;Teacher&quot;, &quot;T... ## $ subject &lt;chr&gt; &quot;PE&quot;, &quot;Drafting&quot;, &quot;Music... ## $ hire_date &lt;dbl&gt; 39690, 39690, 37118, 275... ## $ percent_allocated &lt;dbl&gt; 0.75, 0.25, 1.00, 1.00, ... ## $ full_time &lt;chr&gt; &quot;Yes&quot;, &quot;Yes&quot;, &quot;Yes&quot;, &quot;Ye... ## $ do_not_edit &lt;lgl&gt; NA, NA, NA, NA, NA, NA, ... ## $ certification_9 &lt;chr&gt; &quot;Physical ed&quot;, &quot;Physical... ## $ certification_10 &lt;chr&gt; &quot;Theater&quot;, &quot;Theater&quot;, &quot;V... ## $ certification_11 &lt;lgl&gt; NA, NA, NA, NA, NA, NA, ... 21.6 缺失值检查与处理 21.6.1 purrr &amp; dplyr 技巧 library(purrr) airquality %&gt;% purrr::map(~ sum(is.na(.))) ## $Ozone ## [1] 37 ## ## $Solar.R ## [1] 7 ## ## $Wind ## [1] 0 ## ## $Temp ## [1] 0 ## ## $Month ## [1] 0 ## ## $Day ## [1] 0 airquality %&gt;% purrr::map_df(~ sum(is.na(.))) airquality %&gt;% summarise_at(2:3, ~ sum(is.na(.))) 21.6.2 缺失值替换 airquality %&gt;% mutate_all(funs(replace(., is.na(.), 0))) airquality %&gt;% mutate_all(replace_na, replace = 0) airquality %&gt;% mutate_if(is.numeric, replace_na, replace = 0) airquality %&gt;% mutate_all(as.numeric) %&gt;% mutate_all(~ coalesce(., 0)) tibble( y = c(1, 2, NA, NA, 5), z = c(NA, NA, 3, 4, 5) ) %&gt;% mutate_all(~ coalesce(., 0)) 21.7 标准化 df_mtcars df_mtcars %&gt;% select_if(funs(is.numeric)) # way 1 df_mtcars %&gt;% mutate_at(vars(mpg, disp), ~ scale(., center = T, scale = T)) # way 2 df_mtcars %&gt;% mutate_at(vars(mpg, disp), funs((. - mean(.)) / sd(.))) # way 3 func &lt;- function(x) (x - min(x)) / (max(x) - min(x)) df_mtcars %&gt;% mutate_at(vars(mpg, disp), ~ func(.)) 如果所有的列，都是数值型 func &lt;- function(x) (x - min(x)) / (max(x) - min(x)) df_mtcars %&gt;% mutate_all(~ func(.)) ## Error in x - min(x): 二进列运算符中有非数值参数 但这里数据中还有其他类型（fct, chr），所以这里 mutate_all() 会报错。 这种情形，用mutate_if() func &lt;- function(x) (x - min(x)) / (max(x) - min(x)) df_mtcars %&gt;% mutate_if(is.numeric, ~ func(.)) funs &lt;- list( centered = mean, # Function object scaled = ~ . - mean(.) / sd(.) # Purrr-style lambda ) iris %&gt;% mutate_if(is.numeric, funs) 21.8 arcoss函数 强大的arcoss()函数，估计要替代以上scope函数 iris %&gt;% group_by(Species) %&gt;% summarise( across(starts_with(&quot;Sepal&quot;), mean), Area = mean(Petal.Length * Petal.Width), across(starts_with(&quot;Petal&quot;), min) ) "],
["rowwise.html", "第 22 章 tidyverse中行方向的操作 22.1 问题 22.2 rowwise函数 22.3 Row-wise Summaries 22.4 purrr::map方案 22.5 tidy 的方案 22.6 用slide方案 22.7 用lay方案", " 第 22 章 tidyverse中行方向的操作 library(tidyverse) tidyverse 喜欢数据框，因为一列就是一个向量，一列一列的处理起来很方便。然而我们有时候也要，完成行方向的操作，所以有必要介绍tidyverse中行方向的处理机制。 22.1 问题 df &lt;- tibble(x = 1:3, y = 4:6) df 对每行的求和、求均值、最小值或者最大值？ 22.2 rowwise函数 dplyr提供了rowwise函数，但大神说不推荐 df %&gt;% rowwise() %&gt;% mutate( i = sum(x, y) ) df %&gt;% rowwise() %&gt;% mutate( i = mean(c(x, y) )) df %&gt;% rowwise() %&gt;% mutate(min = min(x,y), max = max(x,y) ) df %&gt;% rowwise() %&gt;% do(i = mean(c(.$x, .$y))) %&gt;% unnest(i) 22.3 Row-wise Summaries df %&gt;% mutate(row_sum = rowSums(.[1:2]) ) df %&gt;% mutate(row_mean = rowMeans(.[1:2]) ) df %&gt;% mutate(t_sum = rowSums(select_if(., is.numeric))) 固然可解决问题， 然而，却不是一个很好的办法，比如除了求和与计算均值，可能还要计算每行的中位数、方差等等， 因为，不是每种计算都对应的row_函数？ 既然是tidyverse ，还是用tidyverse 的方法解决 22.4 purrr::map方案 按照Jenny Bryan的方案 df %&gt;% mutate(t_sum = pmap_dbl(list(x, y), sum)) df %&gt;% mutate(t_sum = pmap_dbl(select_if(., is.numeric), sum)) 计算均值的时候， 然而报错了 df %&gt;% mutate(t_sum = pmap_dbl(select_if(., is.numeric), mean)) tidyverse 总会想出办法来解决，把mean() 变成 lift_vd(mean) df %&gt;% mutate(data = pmap_dbl(select_if(., is.numeric), lift_vd(mean))) 同理 df %&gt;% mutate(t_median = pmap_dbl(select_if(., is.numeric), lift_vd(median))) df %&gt;% mutate(t_sd = pmap_dbl(select_if(., is.numeric), lift_vd(sd))) 22.5 tidy 的方案 我个人推荐的方法(Gather, group, summarize, left_join) new_df &lt;- df %&gt;% mutate(id = row_number()) s &lt;- new_df %&gt;% gather(&quot;time&quot;, &quot;val&quot;, -id) %&gt;% group_by(id) %&gt;% summarize( t_avg = mean(val), t_sum = sum(val) ) s new_df %&gt;% left_join(s) 有点繁琐，但思路清晰 ss &lt;- new_df %&gt;% group_by(id) %&gt;% summarise(t_avg = mean(c(x, y)) ) ss new_df %&gt;% left_join(ss) 之所以有这么多的搞法，是因为没有一个很好的搞法 22.6 用slide方案 slide很强大，可以滚动喔 如果第一个参数是数据框，slide把数据框看作a vector of rows， 然后行方向的滚动，事实上， .x是一个个的小数据框（如下） 与purrr::map不同，因为map把数据框看作列方向的向量， 然后迭代 如果第一个参数是原子型向量的话，还是依次迭代逗号分隔的元素，只不过这里是slide比map更强大的是，还可以是滚动 library(slider) df &lt;- tibble(a = 1:3, b = 4:6) slide( select_if(df, is.numeric), ~.x, .before = 1 ) ## [[1]] ## # A tibble: 1 x 2 ## a b ## &lt;int&gt; &lt;int&gt; ## 1 1 4 ## ## [[2]] ## # A tibble: 2 x 2 ## a b ## &lt;int&gt; &lt;int&gt; ## 1 1 4 ## 2 2 5 ## ## [[3]] ## # A tibble: 2 x 2 ## a b ## &lt;int&gt; &lt;int&gt; ## 1 2 5 ## 2 3 6 df %&gt;% mutate( r_mean = slide_dbl( select_if(df, is.numeric), ~mean(unlist(.x)), .before = 1 ) ) 22.7 用lay方案 lay包解决方案 library(lay) library(dplyr, warn.conflicts = FALSE) iris &lt;- as_tibble(iris) # apply mean to each &quot;row&quot; iris %&gt;% mutate(sepal = lay(across(starts_with(&quot;Sepal&quot;)), mean)) "],
["dot.html", "第 23 章 tidyverse中的dot 23.1 每一行的 . 各自代表什么意思呢? 23.2 占位符 23.3 Lambda函数 23.4 正则表达式 23.5 Unary funciton (只带一个参数的函数) 23.6 more placeholder 23.7 当mutate遇到map 23.8 Dot dot dot 23.9 Don’t confuse 23.10 小结 23.11 回答问题", " 第 23 章 tidyverse中的dot 本章介绍tidyverse的语法中经常遇到.， 不同的场景，含义不同。因此很有必要弄清楚各自的含义。 library(tidyverse) 23.1 每一行的 . 各自代表什么意思呢? read_csv(&quot;./data/wages.csv&quot;) %&gt;% mutate(letter = str_extract(race, &quot;(?&lt;=h)(.)&quot;)) %&gt;% select(., -letter) %&gt;% mutate_at(vars(race), ~ as.factor(.)) %&gt;% mutate_at(vars(sex), ~ if_else(. == &quot;male&quot;, 1, 0)) %&gt;% filter_if(~ is.numeric(.), all_vars(. != 0)) %&gt;% split(.$sex) %&gt;% map(~ lm(earn ~ ., data = .)) %&gt;% map_dfr(~ broom::tidy(.), .id = &quot;sex&quot;) 回答之前，我们先介绍一些相关知识点 23.2 占位符 管道符号%&gt;% 主要功能是传递参数。 y %&gt;% f() is equivalent to f(y) y %&gt;% f(x, .) is equivalent to f(x, y) z %&gt;% f(x, y, arg = .) is equivalent to f(x, y, arg = z) 我们经常这样写 mtcars %&gt;% select(cyl, disp, hp) %&gt;% head(2) 实际上，这里是有占位符的 mtcars %&gt;% select(., cyl, disp, hp) %&gt;% head(., 2) 23.3 Lambda函数 .出现在函数.f的位置上， 就是 purrr 风格的Lambda函数~ fun(.)， mtcars %&gt;% select_at(vars(contains(&quot;ar&quot;)), ~toupper(.)) %&gt;% head(3) 有时候程序员会将~toupper(.)简写成 toupper mtcars %&gt;% select_at(vars(contains(&quot;ar&quot;)), toupper) %&gt;% head(3) 23.4 正则表达式 words &lt;- &quot;the fattest cat.&quot; words %&gt;% str_replace_all(&quot;t.&quot;, &quot;-&quot;) ## [1] &quot;-e fa-es-ca-&quot; words %&gt;% str_replace_all(&quot;t\\\\.&quot;, &quot;-&quot;) ## [1] &quot;the fattest ca-&quot; 23.5 Unary funciton (只带一个参数的函数) mean_rm &lt;- . %&gt;% mean(na.rm = T) c(1, 2, 3, NA) %&gt;% mean_rm ## [1] 2 等价于 # is equivalent to c(1, 2, 3, NA) %&gt;% mean(., na.rm = T) ## [1] 2 23.6 more placeholder iris %&gt;% subset(1:nrow(.) %% 30 == 0) 1:10 %&gt;% {c(min(.), max(.))} ## [1] 1 10 23.7 当mutate遇到map 当dplyr::mutate遇到purrr::map，情况就复杂很多了。然而，这种情况，tidyverse比比皆是。我就多说几句吧 iris %&gt;% head(3) %&gt;% mutate(., r_sum = pmap_dbl(select_if(., is.numeric), sum)) 这里mutate()行，有两个., 实际这两个.都是等待iris %&gt;% head(3)传来的data.frame df &lt;- tibble( mean = c(1, 2), sd = c(2, 4) ) df df %&gt;% dplyr::mutate(., rand = map(mean, ~ rnorm(5, .))) %&gt;% tidyr::unnest_wider(rand) 第一个 .， 是df 第二个 .， 是df中的mean df %&gt;% dplyr::mutate(rand = map2(mean, sd, ~ rnorm(5, .x, .y))) %&gt;% tidyr::unnest_wider(rand) mean传给 .x sd传给 .y 再来一个变态的。（我们不一定要这样写，但我们尽可能的要明白它的意思。） df &lt;- tribble( ~ a, ~b, 1, 10, 2, 11 ) df %&gt;% dplyr::mutate(., sum = purrr::pmap_dbl(., ~sum(...))) 23.8 Dot dot dot commas &lt;- function(...) stringr::str_c(..., collapse = &quot;, &quot;) commas(letters[1:10]) ## [1] &quot;a, b, c, d, e, f, g, h, i, j&quot; 23.9 Don’t confuse 注意：有些函数的参数前缀是 . mutate_all(.tbl, .funs, ...) mutate_if(.tbl, .predicate, .funs, ...) mutate_at(.tbl, .vars, .funs, ..., .cols = NULL) select_all(.tbl, .funs = list(), ...) rename_all(.tbl, .funs = list(), ...) 23.10 小结 tidyvere中 占位符(时常经常和 %&gt;% 一起) Lambda函数 一元函数（LHS） 其他情形 回归公式 正则表达式 注意 有些函数参数以 . 前缀(不要混淆喔! ) 23.11 回答问题 现在回答本章开始的问题 read_csv(&quot;./demo_data/wages.csv&quot;) %&gt;% dplyr::mutate(letter = str_extract(race, &quot;(?&lt;=h)(.)&quot;)) %&gt;% dplyr::select(., -letter) %&gt;% dplyr::mutate_at(vars(race), ~ as.factor(.)) %&gt;% dplyr::mutate_at(vars(sex), ~ if_else(. == &quot;male&quot;, 1, 0)) %&gt;% dplyr::filter_if(~ is.numeric(.), all_vars(. != 0)) %&gt;% split(.$sex) %&gt;% purrr::map(~ lm(earn ~ ., data = .)) %&gt;% purrr::map_dfr(., ~ broom::tidy(.), .id = &quot;sex&quot;) 第1行：路径中.代表当前位置，如果是..表示上一级目录 第2行：正则表达式，代表任何字符 第3行：占位符，等待数据框的传入，也可以简写select(-letter) 第4行: lambda函数，~ as.factor(.)也可以简写as.factor，~和(.)要么都写，要么都不写 第5行：同上,lambda函数 第6行：第一个.代表lambda函数; 第二个.也是lambda函数，但这里它是all_vars(expr)中expr的一种特有写法，代表所有数值型变量，*行方向构成的向量, all_vars(. != 0)函数返回TRUE或FALSE，从而帮助filter()是否筛选该行 第7行：占位符，代表上面传来的数据框 第8行：回归模型lm中，第一个.代表除因变量earn之外所有的变量，第二个.占位符，留给上面的数据框 第9行：第一个.是占位符，代表上面传来的list，第二个.lambda函数，依次对list的元素迭代处理，第二个.是参数名，.id是特有的一个符号。 "],
["rvest.html", "第 24 章 网络爬虫 24.1 链家网 24.2 猪肉价格", " 第 24 章 网络爬虫 library(tidyverse) library(rvest) library(sf) 24.1 链家网 urls &lt;- paste0(&quot;https://sh.lianjia.com/ershoufang/pg&quot;, seq_along(1:2)) scrape_house_info &lt;- function(url) { web &lt;- read_html(url) title &lt;- web %&gt;% html_nodes(&#39;.clear .title a&#39;) %&gt;% html_text() houseinfo &lt;- web %&gt;% html_nodes(&#39;.houseInfo&#39;) %&gt;% html_text() price &lt;- web %&gt;% html_nodes(&#39;.totalPrice span&#39;) %&gt;% html_text() price_per &lt;- web %&gt;% html_nodes(&#39;.unitPrice span&#39;) %&gt;% html_text() df &lt;- data.frame(title, houseinfo, price, price_per) return(df) } tb &lt;- urls %&gt;% map_df(scrape_house_info) tb 24.2 猪肉价格 df_price &lt;- read_html(&quot;https://hangqing.zhuwang.cc/shengzhu/20190905/407978.html&quot;) %&gt;% html_node(&quot;.tabzj&quot;) %&gt;% html_table(header = T) %&gt;% set_names( c(&quot;region&quot;, &quot;name&quot;, &quot;price_today&quot;, &quot;price_yestoday&quot;, &quot;diff_last_day&quot;, &quot;diff_last_week&quot;) ) %&gt;% mutate_at(vars(name), ~str_remove_all(., &quot; &quot;) ) %&gt;% mutate_at(vars(name), ~if_else( name == &quot;黑龙江&quot;, &quot;黑龙江省&quot;, .)) df_price china &lt;- st_read(&quot;./demo_data/chinamap_data/bou2_4p.shp&quot;) %&gt;% st_set_crs(4326) %&gt;% group_by(NAME) %&gt;% summarize() ## Reading layer `bou2_4p&#39; from data source `E:\\R_for_Data_Science\\demo_data\\chinamap_data\\bou2_4p.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 925 features and 7 fields ## geometry type: POLYGON ## dimension: XY ## bbox: xmin: 73.45 ymin: 6.319 xmax: 135.1 ymax: 53.56 ## epsg (SRID): NA ## proj4string: NA china_uni &lt;- china %&gt;% mutate( NAME = iconv(NAME, &quot;GBK&quot;, &quot;UTF-8&quot;) ) %&gt;% mutate_at(vars(NAME), ~str_remove_all(., &quot;自治区|回族|维吾尔|壮族&quot;) ) %&gt;% mutate_at(vars(NAME), ~str_trim(.)) df &lt;- left_join(china_uni, df_price, by = c(&quot;NAME&quot; = &quot;name&quot;)) ggplot(data = df) + geom_sf( aes(fill = price_today &lt; 28), show.legend = FALSE) + geom_sf_text(aes(label = NAME), size = 3 ) + geom_sf_text(aes(label = price_today), size = 3, #nudge_x = c(-0.4, 0.5, 0.7), nudge_y = c(-1, -1, -1) ) + coord_sf(crs = 4326) + ggtitle(&quot;全国猪肉价格地图&quot;) "],
["tidygraph.html", "第 25 章 社会网络分析 25.1 图论基本知识 25.2 网络分析 25.3 Network graph manipulation 25.4 Network analysis 25.5 小结 25.6 Network Visualization 25.7 扩展阅读", " 第 25 章 社会网络分析 本章通过tidygraph宏包介绍社会网络分析。社会网络分析涉及的知识比较多，而tidygraph将网络结构规整地比较清晰，降低了学习难度，很适合入门学习。 library(tidyverse) library(tidygraph) library(ggraph) 25.1 图论基本知识 网络图有两个主要特征: nodes and edges， nodes: edges: 当然还包括其它的概念，比如 adjacency matrix: edge list: Node list: Weighted network graph: Directed and undirected network graph: 有向图 无向图 25.2 网络分析 先介绍tidygraph宏包 25.2.1 tidygraph: A tidy API for graph manipulation 25.2.2 Tidy Network Anaylsis 在 tidygraph 框架, 网络数据可以分解成两个tidy数据框: 一个是 node data 一个是 edge data tidygraph 宏包提供了node数据框和edge数据框相互切换的方案，并且可以使用dplyr的语法操控 tidygraph 提供了常用的网络结构的algorithms，比如，计算网络拓扑结构中节点的重要性、中心度等。 25.2.3 Create network objects 创建网络对象主要有两个函数: tbl_graph(). Creates a network object from nodes and edges data as_tbl_graph(). Converts network data and objects to a tbl_graph network. 案例: 欧盟总统之间通话以及次数。 library(&quot;navdata&quot;) # devtools::install_github(&quot;kassambara/navdata&quot;) data(&quot;phone.call2&quot;) node_list &lt;- phone.call2$nodes node_list edge_list &lt;- phone.call2$edges edge_list 25.2.4 Use tbl_graph Create a tbl_graph network object using the phone call data: phone.net &lt;- tbl_graph(nodes = node_list, edges = edge_list, directed = TRUE) Visualize the network graph ggraph(phone.net, layout = &quot;graphopt&quot;) + geom_edge_link(width = 1, colour = &quot;lightgray&quot;) + geom_node_point(size = 4, colour = &quot;red&quot;) + geom_node_text(aes(label = label), repel = TRUE) + theme_graph() 25.2.5 Use as_tbl_graph mtcars data set: R 的内置数据集，记录了32种不同品牌的轿车的的11个属性 1、we create a correlation matrix network graph library(corrr) res.cor &lt;- mtcars[, c(1, 3:6)] %&gt;% # (1) t() %&gt;% correlate() %&gt;% # (2) shave(upper = TRUE) %&gt;% # (3) stretch(na.rm = TRUE) %&gt;% # (4) filter(r &gt;= 0.998) # (5) res.cor 2、Create the correlation network graph: set.seed(1) cor.graph &lt;- as_tbl_graph(res.cor, directed = FALSE) ggraph(cor.graph) + geom_edge_link() + geom_node_point() + geom_node_text( aes(label = name), size = 3, repel = TRUE ) + theme_graph() 25.2.6 Print out a network object cor.graph ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Node Data: 24 x 1 (active) ## name ## &lt;chr&gt; ## 1 Mazda RX4 ## 2 Mazda RX4 Wag ## 3 Datsun 710 ## 4 Hornet 4 Drive ## 5 Hornet Sportabout ## 6 Valiant ## # ... with 18 more rows ## # ## # Edge Data: 59 x 3 ## from to r ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 1 20 1.00 ## 3 1 8 0.999 ## # ... with 56 more rows 25.2.7 extract the current active data cor.graph %&gt;% activate(edges) %&gt;% arrange(desc(r)) ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Edge Data: 59 x 3 (active) ## from to r ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 10 11 1.00 ## 3 10 12 1.00 ## 4 11 12 1.00 ## 5 8 9 1.00 ## 6 5 18 1.00 ## # ... with 53 more rows ## # ## # Node Data: 24 x 1 ## name ## &lt;chr&gt; ## 1 Mazda RX4 ## 2 Mazda RX4 Wag ## 3 Datsun 710 ## # ... with 21 more rows Note that, to extract the current active data as a tibble, you can use the function as_tibble(cor.graph). 25.3 Network graph manipulation 25.3.1 Car groups info (Number of cylinders) # Car groups info cars.group &lt;- data_frame( name = rownames(mtcars), cyl = as.factor(mtcars$cyl) ) cars.group 25.3.2 Modify the nodes data: # Modify the nodes data cor.graph &lt;- cor.graph %&gt;% activate(nodes) %&gt;% left_join(cars.group, by = &quot;name&quot;) %&gt;% rename(label = name) cor.graph ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Node Data: 24 x 2 (active) ## label cyl ## &lt;chr&gt; &lt;fct&gt; ## 1 Mazda RX4 6 ## 2 Mazda RX4 Wag 6 ## 3 Datsun 710 4 ## 4 Hornet 4 Drive 6 ## 5 Hornet Sportabout 8 ## 6 Valiant 6 ## # ... with 18 more rows ## # ## # Edge Data: 59 x 3 ## from to r ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 1 20 1.00 ## 3 1 8 0.999 ## # ... with 56 more rows 25.3.3 Modify the edge data. # Modify the edge data. cor.graph &lt;- cor.graph %&gt;% activate(edges) %&gt;% rename(weight = r) cor.graph ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Edge Data: 59 x 3 (active) ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 1 20 1.00 ## 3 1 8 0.999 ## 4 1 9 0.999 ## 5 1 11 0.998 ## 6 2 20 1.00 ## # ... with 53 more rows ## # ## # Node Data: 24 x 2 ## label cyl ## &lt;chr&gt; &lt;fct&gt; ## 1 Mazda RX4 6 ## 2 Mazda RX4 Wag 6 ## 3 Datsun 710 4 ## # ... with 21 more rows 25.3.4 Display the final modified graphs object: cor.graph ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Edge Data: 59 x 3 (active) ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 1 20 1.00 ## 3 1 8 0.999 ## 4 1 9 0.999 ## 5 1 11 0.998 ## 6 2 20 1.00 ## # ... with 53 more rows ## # ## # Node Data: 24 x 2 ## label cyl ## &lt;chr&gt; &lt;fct&gt; ## 1 Mazda RX4 6 ## 2 Mazda RX4 Wag 6 ## 3 Datsun 710 4 ## # ... with 21 more rows 25.3.5 Visualize the correlation network set.seed(1) ggraph(cor.graph) + geom_edge_link(aes(width = weight), alpha = 0.2) + scale_edge_width(range = c(0.2, 1)) + geom_node_point(aes(color = cyl), size = 2) + geom_node_text(aes(label = label), size = 3, repel = TRUE) + theme_graph() 25.4 Network analysis 25.4.1 Centrality Centrality is an important concept when analyzing network graph. The tidygraph package contains more than 10 centrality measures, prefixed with the term centrality_ : # centrality_alpha() # centrality_power() # centrality_authority() # centrality_betweenness() # centrality_closeness() # centrality_hub() # centrality_degree() # centrality_pagerank() # centrality_eigen() # centrality_subgraph # centrality_edge_betweenness() example: - use the phone call network graph ( 欧盟总统之间通话以及次数) - compute nodes centrality set.seed(123) phone.net %&gt;% activate(nodes) %&gt;% mutate(centrality = centrality_authority()) ## # A tbl_graph: 16 nodes and 18 edges ## # ## # A directed acyclic simple graph with 1 component ## # ## # Node Data: 16 x 3 (active) ## id label centrality ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 France 1.01e- 1 ## 2 2 Belgium 6.43e-17 ## 3 3 Germany 1.00e+ 0 ## 4 4 Danemark 3.21e-17 ## 5 5 Croatia 3.21e-17 ## 6 6 Slovenia 3.21e-17 ## # ... with 10 more rows ## # ## # Edge Data: 18 x 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 3 9 ## 2 2 1 4 ## 3 1 8 3 ## # ... with 15 more rows set.seed(123) phone.net %&gt;% activate(nodes) %&gt;% mutate(centrality = centrality_authority()) %&gt;% ggraph(layout = &quot;graphopt&quot;) + geom_edge_link(width = 1, colour = &quot;lightgray&quot;) + geom_node_point(aes(size = centrality, colour = centrality)) + geom_node_text(aes(label = label), repel = TRUE) + scale_color_gradient(low = &quot;yellow&quot;, high = &quot;red&quot;) + theme_graph() 25.4.2 Clustering Clustering is a common operation in network analysis and it consists of grouping nodes based on the graph topology. Many clustering algorithms from are available in the tidygraph package and prefixed with the term group_. These include: Infomap community finding. It groups nodes by minimizing the expected description length of a random walker trajectory. R function: group_infomap() Community structure detection based on edge betweenness. It groups densely connected nodes. R function: group_edge_betweenness() example: - use the correlation network graphs (记录了32种不同品牌的轿车的的11个属性) - detect clusters or communities set.seed(123) cluster_mtcars &lt;- cor.graph %&gt;% activate(nodes) %&gt;% mutate(community = as.factor(group_infomap())) cluster_mtcars ## # A tbl_graph: 24 nodes and 59 edges ## # ## # An undirected simple graph with 3 components ## # ## # Node Data: 24 x 3 (active) ## label cyl community ## &lt;chr&gt; &lt;fct&gt; &lt;fct&gt; ## 1 Mazda RX4 6 1 ## 2 Mazda RX4 Wag 6 1 ## 3 Datsun 710 4 3 ## 4 Hornet 4 Drive 6 2 ## 5 Hornet Sportabout 8 2 ## 6 Valiant 6 2 ## # ... with 18 more rows ## # ## # Edge Data: 59 x 3 ## from to weight ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2 1.00 ## 2 1 20 1.00 ## 3 1 8 0.999 ## # ... with 56 more rows cluster_mtcars %&gt;% ggraph(layout = &quot;graphopt&quot;) + geom_edge_link(width = 1, colour = &quot;lightgray&quot;) + geom_node_point(aes(colour = community), size = 4) + geom_node_text(aes(label = label), repel = TRUE) + theme_graph() 25.4.3 More Algorithms 25.5 小结 tidybayes很聪明地将复杂的网络结构用两个数据框表征出来，node 数据框负责节点的属性，edge 数据框负责网络连接的属性，调整其中的一个数据框，另一个也会相应的调整，比如node数据框中删除一个节点，edge数据框就会自动地删除该节点的所有连接。 25.6 Network Visualization 这里主要介绍tidygraph配套的ggraph宏包，它们的作者都是同一个人。 25.6.1 ggraph: A grammar of graphics for relational data ggraph 沿袭了ggplot2的语法规则， cluster_mtcars %&gt;% # Layout ggraph(layout = &quot;graphopt&quot;) + # Edges geom_edge_link( width = 1, colour = &quot;lightgray&quot; ) + # Nodes geom_node_point( aes(colour = community), size = 4 ) + geom_node_text( aes(label = label), repel = TRUE ) + theme_graph() 25.7 扩展阅读 https://www.data-imaginist.com/2017/introducing-tidygraph/ https://github.com/thomasp85/tidygraph https://christophergandrud.github.io/networkD3/ "],
["tidytext.html", "第 26 章 文本挖掘", " 第 26 章 文本挖掘 library(tidyverse) library(tidytext) "],
["tibbletime.html", "第 27 章 时间序列分析", " 第 27 章 时间序列分析 library(tidyverse) library(tibbletime) library(slider) "],
["stars.html", "第 28 章 地理数据处理", " 第 28 章 地理数据处理 library(tidyverse) library(sf) library(stars) "],
["lazyman.html", "第 29 章 懒人系列 29.1 谁帮我敲模型的公式 29.2 模型有了，不知道怎么写论文？ 29.3 模型评估一步到位 29.4 统计描述不用愁 29.5 列名太乱了 29.6 比count()更懂我的心 29.7 代码太乱了，谁帮我整理下 29.8 正则表达式太南了 29.9 颜控怎么配色？ 29.10 宏包太多 29.11 犹抱琵琶半遮面 29.12 整理Rmarkdown 29.13 如何有效的提问 29.14 程序结束后记得提醒我 29.15 多张图摆放 29.16 缺失值处理 29.17 看看数据什么情况 29.18 画图颜色好看不 29.19 管道都不想 29.20 各种插件，任君选取", " 第 29 章 懒人系列 R社区上很多大神，贡献了很多非常优秀的工具，节省了我们的时间，也给我们的生活增添了无限乐趣。我平时逛github的时候时整理一些，现在分享出来供像我一样的懒人用，因此本文档叫“懒人系列”。欢迎大家补充。 29.1 谁帮我敲模型的公式 library(tidyverse) library(equatiomatic) ## https://github.com/datalorax/equatiomatic mod1 &lt;- lm(mpg ~ cyl + disp, mtcars) extract_eq(mod1) \\[ \\text{mpg} = \\alpha + \\beta_{1}(\\text{cyl}) + \\beta_{2}(\\text{disp}) + \\epsilon \\] extract_eq(mod1, use_coefs = TRUE) \\[ \\text{mpg} = 34.66 - 1.59(\\text{cyl}) - 0.02(\\text{disp}) + \\epsilon \\] 29.2 模型有了，不知道怎么写论文？ library(report) ## https://github.com/easystats/report model &lt;- lm(Sepal.Length ~ Species, data = iris) report(model) ## We fitted a linear model to predict Sepal.Length with Species.The model&#39;s explanatory power is substantial (R2 = 0.62, adj. R2 = 0.61). The model&#39;s intercept is at -1.01. Within this model: ## ## - The effect of Species [versicolor] is positive and can be considered as significant (beta = 1.12, 95% CI [0.88, 1.37], p &lt; .001). ## - The effect of Species [virginica] is positive and can be considered as significant (beta = 1.91, 95% CI [1.66, 2.16], p &lt; .001). 29.3 模型评估一步到位 library(performance) model &lt;- lm(mpg ~ wt * cyl + gear, data = mtcars) check_model(model) 29.4 统计描述不用愁 library(gtsummary) ## https://github.com/ddsjoberg/gtsummary trial %&gt;% select(trt, age, grade, response) %&gt;% tbl_summary(by = trt, missing = &quot;no&quot;) %&gt;% add_p() %&gt;% add_overall() %&gt;% add_n() %&gt;% bold_labels() Characteristic N Overall, N = 200 Drug A, N = 98 Drug B, N = 102 p-value Age, yrs 189 47 (38, 57) 46 (37, 59) 48 (39, 56) 0.7 Grade 200 0.9 I 68 (34%) 35 (36%) 33 (32%) II 68 (34%) 32 (33%) 36 (35%) III 64 (32%) 31 (32%) 33 (32%) Tumor Response 193 61 (32%) 28 (29%) 33 (34%) 0.6 直接复制到论文即可 t1 &lt;- glm(response ~ trt + age + grade, trial, family = binomial) %&gt;% tbl_regression(exponentiate = TRUE) t2 &lt;- survival::coxph(survival::Surv(ttdeath, death) ~ trt + grade + age, trial) %&gt;% tbl_regression(exponentiate = TRUE) tbl_merge( tbls = list(t1, t2), tab_spanner = c(&quot;**Tumor Response**&quot;, &quot;**Time to Death**&quot;) ) Characteristic OR 95% CI p-value HR 95% CI p-value Chemotherapy Treatment Drug A — — — — Drug B 1.13 0.60, 2.13 0.7 1.30 0.88, 1.92 0.2 Age, yrs 1.02 1.00, 1.04 0.10 1.01 0.99, 1.02 0.3 Grade I — — — — II 0.85 0.39, 1.85 0.7 1.21 0.73, 1.99 0.5 III 1.01 0.47, 2.15 &gt;0.9 1.79 1.12, 2.86 0.014 29.5 列名太乱了 library(janitor) ## install.packages(&quot;janitor&quot;) ## https://github.com/sfirke/janitor fake_raw &lt;- tibble::tribble( ~id, ~`count/num`, ~W.t, ~Case, ~`time--d`, ~`%percent`, 1L, &quot;china&quot;, 3L, &quot;w&quot;, 5L, 25L, 2L, &quot;us&quot;, 4L, &quot;f&quot;, 6L, 34L, 3L, &quot;india&quot;, 5L, &quot;q&quot;, 8L, 78L ) fake_raw fake_raw %&gt;% clean_names() 29.6 比count()更懂我的心 mtcars %&gt;% count(cyl) mtcars %&gt;% janitor::tabyl(cyl) 29.7 代码太乱了，谁帮我整理下 ## install.packages(&quot;styler&quot;) 安装后，然后这两个地方点两下，就发现你的代码整齐很多了 29.8 正则表达式太南了 library(inferregex) ## remotes::install_github(&quot;daranzolin/inferregex&quot;) s &lt;- &quot;abcd-9999-ab9&quot; infer_regex(s)$regex ## [1] &quot;^[a-z]{4}-\\\\d{4}-[a-z]{2}\\\\d$&quot; 有了它，妈妈再也不担心我的正则表达式了 29.9 颜控怎么配色？ library(ggthemr) ## devtools::install_github(&#39;cttobin/ggthemr&#39;) ggthemr(&#39;dust&#39;) mtcars %&gt;% mutate(cyl = factor(cyl)) %&gt;% ggplot(aes(x = mpg, fill = cyl, colour = cyl)) + geom_density(alpha = 0.75) + labs(fill = &#39;Cylinders&#39;, colour = &#39;Cylinders&#39;, x = &#39;MPG&#39;, y = &#39;Density&#39;) + legend_top() 用完别忘了 ggthemr_reset() 29.10 宏包太多 library(pacman) ##p_load(lattice, foreign, boot, rpart) 唉，这个library()都要偷懒，真服了你们了 29.11 犹抱琵琶半遮面 ##https://github.com/EmilHvitfeldt/gganonymize library(ggplot2) library(gganonymize) ggg &lt;- ggplot(mtcars, aes(as.factor(cyl))) + geom_bar() + labs(title = &quot;Test title&quot;, subtitle = &quot;Test subtitle, this one have a lot lot lot lot lot more text then the rest&quot;, caption = &quot;Test caption&quot;, tag = 1) + facet_wrap(~vs) gganonomize(ggg) 你可以看我的图，但就不想告诉你图什么意思，因为我加密了 29.12 整理Rmarkdown # remotes::install_github(&quot;tjmahr/WrapRmd&quot;) # remotes::install_github(&quot;fkeck/quickview&quot;) # remotes::install_github(&quot;mwip/beautifyR&quot;) 29.13 如何有效的提问 直接看官方网站，这里不举例了 ## install.packages(&quot;reprex&quot;) ## https://reprex.tidyverse.org/ 29.14 程序结束后记得提醒我 ## beepr::beep(sound = &quot;mario&quot;) 你听到了声音吗? 29.15 多张图摆放 library(patchwork) p1 &lt;- ggplot(mtcars) + geom_point(aes(mpg, disp)) p2 &lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear)) p3 &lt;- ggplot(mtcars) + geom_smooth(aes(disp, qsec)) p1 + p2 + p3 29.16 缺失值处理 library(naniar) ##https://github.com/njtierney/naniar airquality %&gt;% group_by(Month) %&gt;% miss_var_summary() 29.17 看看数据什么情况 library(visdat) vis_dat(airquality) 29.18 画图颜色好看不 scales也是大神的作品，功能多多 ## https://github.com/r-lib/scales library(scales) show_col(viridis_pal()(10)) 先看看颜色，再选择 29.19 管道都不想 管道都不想写， 写代码还有美感？ ## library(nakepipe) 29.20 各种插件，任君选取 ## https://github.com/daattali/addinslist "],
["exams.html", "A 期末考试 A.1 方式 A.2 要求 A.3 数据集", " A 期末考试 研究生生涯的主要工作就是学习，而学以致用是最好的学习路径。考虑同学们不同的学科背景，同时也参考国内其它高校的做法，本学期《数据科学中的 R 语言》期末考试安排如下： A.1 方式 结合所在学科，找一篇与自己研究方向相关的文献，用课堂上学到的R统计编程技能，重复文献的数据分析过程。 A.2 要求 在2020年06月15日前，将以下资料打包并提交38552109@qq.com邮箱 所重复的文献（并在文献中高亮你重复的部分） 数据 Rmarkdown源代码 分析结果(生成的pdf或者html文件) 注明学号和姓名 A.3 数据集 仅供参考 https://datahub.io/collections/economic-data https://cnki.net/ https://osf.io/ https://www.kaggle.com/datasets https://toolbox.google.com/datasetsearch https://chfs.swufe.edu.cn/（中国家庭金融调查） http://www.isss.pku.edu.cn/cfps/index.htm（中国家庭追踪调查） http://www.ciejournal.org/ (中国工业经济) http://www.stats.gov.cn/tjsj/ndsj/ (中国统计年鉴) "],
["references.html", "参考文献", " 参考文献 "]
]
